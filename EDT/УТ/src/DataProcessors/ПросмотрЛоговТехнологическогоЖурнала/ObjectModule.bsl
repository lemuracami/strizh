
#Если Сервер Или ТолстыйКлиентОбычноеПриложение Или ВнешнееСоединение Тогда

// Функция определяет существующий каталог на сервере,
// в котором будет создан технологический журнал. 
// Возвращает имя этого каталога.
Функция ПутьККонфигурационномуФайлу()
	
	СистемнаяИнформация = Новый СистемнаяИнформация();
	Если НЕ ((СистемнаяИнформация.ТипПлатформы = ТипПлатформы.Windows_x86) ИЛИ (СистемнаяИнформация.ТипПлатформы = ТипПлатформы.Windows_x86_64)) Тогда
		Возврат Неопределено;
	КонецЕсли;
	
	КаталогаОбщихКонфигурационныхФайлов = КаталогПрограммы() + "conf";
	#Если ТолстыйКлиентОбычноеПриложение Тогда
		РазделительПути = ПолучитьРазделительПути();
	#Иначе 
		РазделительПути = ПолучитьРазделительПутиСервера();
	#КонецЕсли
	ФайлУказатель = Новый Файл(КаталогаОбщихКонфигурационныхФайлов + РазделительПути + "conf.cfg");
	Если ФайлУказатель.Существует() Тогда
		ФайлКонфигурации = Новый ЧтениеТекста(ФайлУказатель.ПолноеИмя);
		Строка = ФайлКонфигурации.ПрочитатьСтроку();
		Пока Строка <> Неопределено Цикл
			Позиция = Найти(Строка, "ConfLocation=");
			Если Позиция > 0 Тогда 
				КаталогКонфигурацииПриложения = СокрЛП(Сред(Строка, Позиция + 13));
				Прервать;
			КонецЕсли;
			Строка = ФайлКонфигурации.ПрочитатьСтроку();
		КонецЦикла;
	КонецЕсли;
	
	
	Возврат КаталогКонфигурацииПриложения;
КонецФункции
#КонецЕсли

#Если Сервер Или ТолстыйКлиентОбычноеПриложение Или ВнешнееСоединение Тогда
#Область СохранениеВосстановлениеНастроекОбработки

Процедура ВосстановитьНастройки(Форма) Экспорт
	
	ИмяНастройкиНачальныхЗначений = ПолучитьНазваниеНастройки();
	НачальныеНастройки = ХранилищеНастроекДанныхФорм.Загрузить(ИмяНастройкиНачальныхЗначений,ИмяНастройкиНачальныхЗначений );
	
	Если ТипЗНЧ(НачальныеНастройки) <> Тип("Структура") Тогда
		Возврат;
	КонецЕсли;
	
	ЗаполнитьЗначенияСвойств( Форма, НачальныеНастройки);
	ЗаполнитьЗначенияСвойств( Форма.Объект, НачальныеНастройки);
	
КонецПроцедуры

Процедура СохранитьНастройки( Форма )  Экспорт
	
	СтруктураНастроекДляСохранения 
	= Новый Структура("ИмяЛогФайла,СтрокаПоиска,ПользовательскийФайлLogcfg,
	|ИдентификаторПроцессаОС,КаталогСЛогФайлами,КолВоСтрокДляОтображения,ОтображатьПервыеИлиПоследние,
	|ИЛИ_И,НЕ,ИсточникЖурнала,ФорматированныйПросмотр,РазмерШрифта,ИнтервалВремениДо,ИнтервалВремениОт,
	|ПоискВТерминахСУБД");
	ЗаполнитьЗначенияСвойств(СтруктураНастроекДляСохранения, Форма);
	ЗаполнитьЗначенияСвойств(СтруктураНастроекДляСохранения, Форма.Объект);
	
	ИмяНастройкиНачальныхЗначений = ПолучитьНазваниеНастройки();
	ХранилищеНастроекДанныхФорм.Сохранить(ИмяНастройкиНачальныхЗначений,ИмяНастройкиНачальныхЗначений, СтруктураНастроекДляСохранения);
	
КонецПроцедуры

Функция ПолучитьНазваниеНастройки()
	Возврат "НачальныеНастройкиПриЗапускеОбработкиПросмотраЛоговТехнологическогоЖурнала";
КонецФункции 

#КонецОбласти

#Область ФорматированиеТекстовойИнформацииЛогов

// Процедура производит замену имен SQL на 1C
//
Функция ПоказатьВТерминахБД( Знач ВременныйТекст ,АдресВХранилищеСтруктураХраненияБазыДанных) Экспорт
	
	СтруктураХраненияБД = Неопределено;
	Если НЕ ЭтоАдресВременногоХранилища(АдресВХранилищеСтруктураХраненияБазыДанных) Тогда
		АдресВХранилищеСтруктураХраненияБазыДанных = ПолучитьОписаниеХраненияБД();
	КонецЕсли;
	
	СтруктураХраненияБД = ПолучитьИзВременногоХранилища(АдресВХранилищеСтруктураХраненияБазыДанных);
	
	Если ТипЗнч(СтруктураХраненияБД) = Тип("ТаблицаЗначений") Тогда
		
		Для каждого СтрокаХранения Из СтруктураХраненияБД Цикл
			Если НЕ ПустаяСтрока( СтрокаХранения.ИмяТаблицы ) И Найти(ВременныйТекст, СтрокаХранения.ИмяТаблицыХранения) <> 0 Тогда
				ВременныйТекст = СтрЗаменить(ВременныйТекст, СтрокаХранения.ИмяТаблицыХранения, СтрокаХранения.ИмяТаблицы);
				
				Для каждого Поле Из СтрокаХранения.Поля Цикл
					Если Найти(ВременныйТекст, Поле.ИмяПоляХранения) <>0 И НЕ ПустаяСтрока(Поле.ИмяПоля) Тогда
						ВременныйТекст = СтрЗаменить(ВременныйТекст, Поле.ИмяПоляХранения, Поле.ИмяПоля);
					КонецЕсли;
				КонецЦикла;
			КонецЕсли;
		КонецЦикла;
		
	КонецЕсли;
	
	Возврат ВременныйТекст;
	
КонецФункции

Функция ПолучитьФорматированныйЗапросИлиТекстНаСервере(Знач ТекущийТекст, Знач ФорматироватьТекст= Истина, РазмерШрифта = 10 ) Экспорт
	
	ТекстHTML = "<html>%2<body>%1</body></html>";
	ТекстУстановкиСтиля = СтрЗаменить("<style><!-- *{font-family:Courier New;font-size:%2pt;} --></style>", "%2", Строка(РазмерШрифта));
	
	ТекстHTML = СтрЗаменить( ТекстHTML, "%2", ТекстУстановкиСтиля);
	
	Если НЕ ФорматироватьТекст Тогда
		ОбработанныйТекстЗапроса =   СтрЗаменить( ТекстHTML,"%1",  ТекущийТекст  )  ;
	Иначе
		
		ОтформатированныйТекст = ОбработатьТекстЗапроса(ТекущийТекст);
		ОтформатированныйТекст = СтрЗаменить(ОтформатированныйТекст, Символы.ПС, "<br>") ;
		ОтформатированныйТекст = СтрЗаменить(ОтформатированныйТекст, "  ", "&nbsp") ;
		
		ШрифтТекстаНачало = "";		ШрифтТекстаКонцовка =  "";
		
		ШрифтКлючевоеСловоНачало = "<font  color=""Blue"" >";
		ШрифтКлючевоеСловоКонцовка = "</font>";
		
		КлючевыеСлова = ПолучитьКлючевыеСлова();
		
		ОбработанныйТекстЗапроса =   СтрЗаменить( ТекстHTML,"%1", ШрифтТекстаНачало + ОтформатированныйТекст + ШрифтТекстаКонцовка )  ;
		
		Для каждого ИсключенноеСлово Из КлючевыеСлова Цикл
			КлючевоеСлово = ИсключенноеСлово.Ключ;
			Цвет = Сред(СтрЗаменить(ИсключенноеСлово.Значение, "/CR",""),2);
			
			ОбработанныйТекстЗапроса = СтрЗаменить(ОбработанныйТекстЗапроса,КлючевоеСлово, СтрЗаменить(ШрифтКлючевоеСловоНачало,"Blue",Цвет) + КлючевоеСлово + ШрифтКлючевоеСловоКонцовка);
		КонецЦикла;
		
	КонецЕсли;                
	
	Возврат ОбработанныйТекстЗапроса;
КонецФункции

// Функция производит форматирование переданного текста.
// Текстом может быть как запрос SQL, так и просто текстовая информация Из лог-файла.
// Добавим в  места нахождения некоторых ключевых операторов символы перевода строки.
// Чтобы в дальнейшем получить более наглядное форматирование.
Функция ОбработатьТекстЗапроса(ИсходныйТекстЗапроса)
	
	
	КлючевыеСлова = ПолучитьКлючевыеСлова();
	
	ВременныйТекст = СтрЗаменить(ИсходныйТекстЗапроса,Символы.ПС," ");
	ВременныйТекст = СтрЗаменить(ВременныйТекст, Символ(13)," ");
	ВременныйТекст = СтрЗаменить(ВременныйТекст,", ",",");
	ВременныйТекст = СтрЗаменить(ВременныйТекст, "  ", " ");
	ВременныйТекст = СтрЗаменить(ВременныйТекст,",", ","+Символы.ПС);
	
	// Добавим переводы строк перед ключевыми словечками, там, где это надо.
	Для каждого ИсключенноеСлово Из КлючевыеСлова Цикл
		
		Если Найти( ИсключенноеСлово.Значение ,"/CR")=0  Тогда
				Продолжить;
		КонецЕсли;
		КлючевоеСлово = ИсключенноеСлово.Ключ;
		
		ВременныйТекст = СтрЗаменить(ВременныйТекст,КлючевоеСлово, Символы.ПС+КлючевоеСлово);
	КонецЦикла;
	
	ФорматныйСимвол = " ";
	Счетчик =0;
	СимволПрефикса = "%@&";
	
	СписокФрагментов = Новый СписокЗначений;
	
	// Разбираем переданную строку на блоки ограниченные скобками.
	// В результате, после цикла, должен получиться массив строк с такими блоками.
	Пока Истина Цикл
		Позиция1 = -1;Позиция2=-1;
		
		// Ищем закрывающую скобку
		Позиция1 = Найти(ВременныйТекст, ")");
		Если Позиция1 = 0  Тогда			Прервать;	КонецЕсли;
		
		// Ищем для закрывающей скобки открывшую ее скобку.
		Для Счетчик2=-Позиция1+1 По -1 Цикл
			Если Сред(ВременныйТекст,-Счетчик2,1)= "(" Тогда
				Позиция2 = -Счетчик2;
				Прервать;
			КонецЕсли;
		КонецЦикла;
		
		Если Позиция2=-1 Тогда
			ПоказатьСообщениеПользователю(НСтр("ru = 'Проблема! НЕ совпадает кол-во открытых И закрытых скобок.'"));
			Прервать;
		КонецЕсли;
		
		Счетчик = Счетчик +1;
		Префикс = СимволПрефикса+ФОрмат(Счетчик,"ЧЦ=6;ЧГ=");
		текст = Сред(ВременныйТекст,Позиция2,Позиция1-Позиция2+1);
		ВременныйТекст = СтрЗаменить(ВременныйТекст,текст,Префикс );
		
		// Проведем первичное форматирование. 
		// Перед открывающей скобкой добавим перевод строки.
		текст = СтрЗаменить(текст, Символы.ПС, Символы.ПС+ ФорматныйСимвол+ФорматныйСимвол);
		текст = СтрЗаменить(текст, "(" ,  Символы.ПС+ "("+Символы.ПС);
		
		// После закрывающей скобки - тоже перевод строки.
		текст = СтрЗаменить(текст, ")" ,  Символы.ПС+")"+Символы.ПС);
		
		СписокФрагментов.Добавить(Префикс, текст);
		
	КонецЦикла;
	
	// Собираем по-новой текст запроса, уже с добавленными переводами строк.
	Пока Найти(ВременныйТекст,СимволПрефикса)>0 Цикл
		Для Счетчик = -СписокФрагментов.Количество() По -1 Цикл
			СтрокаСписка = СписокФрагментов[-Счетчик-1];
			ВременныйТекст = СтрЗаменить(ВременныйТекст, СтрокаСписка.Значение, СтрокаСписка.Представление);
		КонецЦикла;
	КонецЦикла;
	
	// В результате преобразований текста могут появиться двойные пустые переносы.
	// Подправим это, чтоб лучше выглядело.
	ВременныйТекст = СтрЗаменить(ВременныйТекст, Символы.ПС+Символы.ПС, Символы.ПС );
	ВременныйТекст = СтрЗаменить(ВременныйТекст, "("+Символы.ПС+")", "()" );
	
	// Теперь произведем форматирование выравнивающим символом (или фразой), таким образом
	// чтобы было видно вложенные блоки запроса. Закрывающие скобки должны стоять на том же уровне, что и открывающие,
	// а служебные слова, поля запросов должны находиться на своих местах своих запросов и вложенных запросов.
	//
	// Алгоритм таков: Ищется открывающая скобка. Затем, от этой скобки и до ее закрывающей скобки 
	// в каждую строку добавляется новый символ выравнивания. Выравнивающий символ также добавляется перед 
	// открывающей скобкой и после закрывающей.
	// И так обрабатываются все открывающие скобки.
	//
	СимволОтступа = "  ";
	
	МассивКлючей = Новый Массив();
	МассивКлючей.Добавить("(");
	МассивКлючей.Добавить(")");
	МассивКлючей.Добавить("CASE");
	МассивКлючей.Добавить("END");
	
	НомерКлюча=1;
	Пока НомерКлюча <= МассивКлючей.Количество() Цикл
		
		ОткрывающийКлюч = МассивКлючей[НомерКлюча-1] ;
		ЗакрывающийКлюч = МассивКлючей[НомерКлюча];
		
		НомерВСтроке = 0;
		Пока Истина Цикл
			НомерВСтроке=НомерВСтроке+1;
			Если НомерВСтроке > СтрДлина(ВременныйТекст) Тогда
				Прервать;
			КонецЕсли;
			
			Если Сред(ВременныйТекст,НомерВСтроке,СтрДлина(ОткрывающийКлюч)) <>  ОткрывающийКлюч Тогда 			Продолжить;	КонецЕсли;
			ВременныйТекст = Лев(ВременныйТекст,НомерВСтроке-1)+СимволОтступа+Сред(ВременныйТекст, НомерВСтроке);
			НомерВСтроке=НомерВСтроке+СтрДлина(СимволОтступа);
			
			СчетчикСкобок = 0;
			Для НомерДальше=НомерВСтроке По СтрДлина(ВременныйТекст) Цикл
				
				Если Сред(ВременныйТекст,НомерДальше,1) = Символы.ПС Тогда
					ВременныйТекст = Лев(ВременныйТекст,НомерДальше)+СимволОтступа+Сред(ВременныйТекст,НомерДальше+1);
				ИначеЕсли Сред(ВременныйТекст,НомерДальше,СтрДлина(ОткрывающийКлюч)) = ОткрывающийКлюч Тогда
					СчетчикСкобок  = СчетчикСкобок +1;
				ИначеЕсли Сред(ВременныйТекст,НомерДальше,СтрДлина(ЗакрывающийКлюч)) = ЗакрывающийКлюч Тогда
					СчетчикСкобок  = СчетчикСкобок -1;
				КонецЕсли;
				
				Если СчетчикСкобок =0 Тогда
					Прервать;
				КонецЕсли;
				
			КонецЦикла;
			
			
		КонецЦикла;
		
		НомерКлюча=НомерКлюча+2;
	КонецЦикла;
	
	ОбработанныйТекстЗапроса = ВременныйТекст;
	
	Возврат  ОбработанныйТекстЗапроса;
КонецФункции

// Функция возвращает массив возможных ключевых фраз, которые могут встретиться в тексте.
// Сделана поддержка пары ключей:
// Ключ начинается обязательно с символа "@", после него , через слэш перечисляются ключи:
// /CR - вставить перевод строки перед ключевым словом/фразой.
// /color - выделить данное ключевое слово/фразу цветом. 
//
// Выделение цветом сделано для HTML документа, который используется в версии управляемого 
// приложения.
// 
Функция ПолучитьКлючевыеСлова() 
	
	КлючевыеСлова = Новый Соответствие;
	
	КлючевыеСлова.Вставить("FROM",		"/CR/blue");
	КлючевыеСлова.Вставить(" ON ",		"/blue");
	КлючевыеСлова.Вставить("LEFT",		"/CR/blue");
	КлючевыеСлова.Вставить("RIGHT",		"/CR/blue");
	КлючевыеСлова.Вставить("INNER",		"/CR/blue");
	КлючевыеСлова.Вставить("OUTER",		"/CR/blue");
	КлючевыеСлова.Вставить("JOIN",		"/blue");
	КлючевыеСлова.Вставить("WHERE",		"/CR/blue");
	КлючевыеСлова.Вставить("SELECT",	"/CR/blue");
	КлючевыеСлова.Вставить(" TOP ",		"/blue");
	КлючевыеСлова.Вставить("DISTINCT",	"/blue");
	КлючевыеСлова.Вставить("UPDATE",	"/CR/blue");
	КлючевыеСлова.Вставить("DELETE",	"/CR/blue");
	КлючевыеСлова.Вставить("INSERT",	"/CR/blue");
	КлючевыеСлова.Вставить("CHANGE",	"/CR/blue");
	КлючевыеСлова.Вставить("ORDER BY",	"/CR/blue");
	
	КлючевыеСлова.Вставить("WHEN"		,"/CR/brown");
	КлючевыеСлова.Вставить("CASE"		,"/brown");
	КлючевыеСлова.Вставить("THEN"		,"/brown");
	КлючевыеСлова.Вставить("ELSE",		"/brown");
	КлючевыеСлова.Вставить("END",		"/CR/brown");
	КлючевыеСлова.Вставить("IS NULL",	"/brown");
	КлючевыеСлова.Вставить("NOT",		"/brown");
	КлючевыеСлова.Вставить(" AND ",		"/brown");
	КлючевыеСлова.Вставить(" OR ",		"/brown");
	
	Возврат КлючевыеСлова;
	
КонецФункции

#КонецОбласти

#Область ВключениеВыключениеЛоговТехнологическогоЖурналаПолучениеФайловЛоговРазборТекстаСтрок

Процедура УстановитьНачалоПозицииЧтения(ЧтениеФайла ,  ТребуемаяПозицияВФайле)
	
	ПорцияПропуска = Мин(10000000, Цел(ТребуемаяПозицияВФайле/10 ));
	ДлинаПрочитанногоТекста = 0;
	
	Пока ПорцияПропуска>0 Цикл
		
		ВременныйТекст = ЧтениеФайла.Прочитать(ПорцияПропуска);
		Если ВременныйТекст = Неопределено Тогда		Прервать;	КонецЕсли;
		
		ДлинаПрочитанногоТекста = ДлинаПрочитанногоТекста + СтрДлина(ВременныйТекст);
		ВременныйТекст = Неопределено;
		
		ПорцияПропуска = Мин(ПорцияПропуска, Цел(ТребуемаяПозицияВФайле - ДлинаПрочитанногоТекста));
	КонецЦикла;
	
КонецПроцедуры

// Возвращает реальный размер файла с учетом UTF кодировки.
// 
Функция ВычислитьРеальныйРазмерФайла(Файл)
	
	ЧтениеФайла = Новый ЧтениеТекста(Файл.ПолноеИмя,,,,Ложь);
	ПорцияПропуска = 10000000;
	ДлинаПрочитанногоТекста = 0;
	
	ВременныйТекст = ЧтениеФайла.Прочитать(ПорцияПропуска);
	Пока ВременныйТекст <> Неопределено Цикл
		
		ДлинаПрочитанногоТекста = ДлинаПрочитанногоТекста + СтрДлина(ВременныйТекст);
		ВременныйТекст = Неопределено;
		
		ВременныйТекст = ЧтениеФайла.Прочитать(ПорцияПропуска);
	КонецЦикла;
	
	ЧтениеФайла = Неопределено;
	
	Возврат ДлинаПрочитанногоТекста;
	
КонецФункции 

// Функция возвращает список имен таблиц в терминах СУБД,
// разыскивая их в соответствующей таблице по введенным именам 1С.
Функция КонвертироватьИмена1СВИменаТаблицСУБД(МассивСтрокШаблонПоиска,АдресВХранилищеСтруктураХраненияБазыДанных);
	
	МассивПоискаПоИменамТаблицСУБД = Новый Массив;
	
	Если ЭтоАдресВременногоХранилища(АдресВХранилищеСтруктураХраненияБазыДанных) Тогда
		ТЗСтруктураБД = ПолучитьИзВременногоХранилища(АдресВХранилищеСтруктураХраненияБазыДанных);
		Если ТипЗНЧ(ТЗСтруктураБД) = Тип("ТаблицаЗначений") Тогда
			
			// Перебираем термины 1С.
			Для каждого СтрокаШаблонПоиска Из МассивСтрокШаблонПоиска Цикл
				// Пробуем найти термин 1С в терминах СУБД.
				МассивПоиска = ТЗСтруктураБД.НайтиСтроки(Новый Структура("КраткоеИмя",ВРег(СтрокаШаблонПоиска)));
				Если НЕ ПустаяСтрока(СтрокаШаблонПоиска) И МассивПоиска.Количество()>0 Тогда
					// Нашлось имя в СУБД. Добавляем найденные имена объекта, возможно его подчиненных ТЧ.
					Для каждого ЭлМассива Из МассивПоиска Цикл
						МассивПоискаПоИменамТаблицСУБД.Добавить(ЭлМассива.ИмяТаблицыХранения);
					КонецЦикла;
				Иначе
					// НЕ нашлось. Добавляем тот текст, что есть. 
					МассивПоискаПоИменамТаблицСУБД.Добавить(СтрокаШаблонПоиска);
				КонецЕсли;
				
			КонецЦикла;
		КонецЕсли;
		
	КонецЕсли;
	
	МассивСтрокШаблонПоиска = МассивПоискаПоИменамТаблицСУБД;
	
КонецФункции

// Процедура разбирает на строки выбранный лог-файл и загружает его содержимое 
// в табличную часть обработки.
//
Процедура ЗагрузитьЛогФайл(ПереданныйФайл, Форма) Экспорт
	
	ТаблицаСтрок = Форма.ТаблицаСтрок;
	
	Если ТипЗНЧ(ПереданныйФайл) = Тип("Структура") Тогда
		
		// Переданный файл может быть передан в виде структуры, в которой файл 
		// находится во временном хранилище , т.е. передается с клиента сюда, на сервер.
		
		Если ЭтоАдресВременногоХранилища(ПереданныйФайл.АдресФайлаВХранилище) Тогда
			ЛокальныйИмяЛогФайла = ПолучитьИмяВременногоФайла( ПолучитьРасширениеФайла(ПереданныйФайл.ИмяФайла ));
			ПолучитьИзВременногоХранилища(ПереданныйФайл.АдресФайлаВХранилище).Записать(ЛокальныйИмяЛогФайла);
			УдалитьИзВременногоХранилища(ПереданныйФайл.АдресФайлаВХранилище);
		КонецЕсли;
		
	ИначеЕсли ТипЗНЧ(ПереданныйФайл) = Тип("Строка") Тогда	
		// Или же файл уже раз был передан сюда на сервер. 
		// Тогда мы в переданном файле имеем полный путь к уже имеющемуся тут файлу.
		// Повторно передавать один И тот же файл смысла нет. 
		// Воспользуемся тем что этот файл есть уже на сервере.
		ЛокальныйИмяЛогФайла = ПереданныйФайл;
	Иначе
		ПоказатьСообщениеПользователю(НСтр("ru = 'Проблема с загрузкой файла!'"));
		Возврат;
	КонецЕсли;
	
	// Запомним для следующих попыток загрузок, где расположен наш файл логов,
	// чтобы повторно не гнать файл с клиента на сервер.
	Форма.Объект.ИмяЛогФайлаНаСервере = ЛокальныйИмяЛогФайла;
	
	Файл = Новый Файл(ЛокальныйИмяЛогФайла);
	
	Если НЕ Файл.Существует() Тогда
		ПоказатьСообщениеПользователю(НСтр("ru = 'Проблема с загрузкой файла! Файл не существует!'"));
		Возврат;
	КонецЕсли;
	
	СтруктураУсловийПоиска = Новый Структура();
	
	СтруктураУсловийПоиска.Вставить("Лог_ИЛИ",Форма.ИЛИ_И=0);
	СтруктураУсловийПоиска.Вставить("Лог_И",Форма.ИЛИ_И=1);
	СтруктураУсловийПоиска.Вставить("Лог_НЕ",Форма.НЕ=1);
	СтруктураУсловийПоиска.Вставить("ИнтервалВремениОт",Форма.ИнтервалВремениОт);
	СтруктураУсловийПоиска.Вставить("ИнтервалВремениДо",Форма.ИнтервалВремениДо);
	
	
	ПоискВТерминахСУБД 	= Форма.ПоискВТерминахСУБД;
	
	ПорогРазмераФайла = 20000000;// Файлы меньше этого размера, будут читаться за один раз. 
	// Если больше, то будут прочитываться блоками.
	ОтображатьПервыеИлиПоследние = Форма.ОтображатьПервыеИлиПоследние;
	КолВоСтрокДляОтображения = Форма.КолВоСтрокДляОтображения;
	
	ПолныйРазмерФайла = Файл.Размер();
	РазмерФайлаБезUTF = ВычислитьРеальныйРазмерФайла(Файл);
	ПорцияДанныхДляЧтения = ? ( РазмерФайлаБезUTF > ПорогРазмераФайла, Цел(РазмерФайлаБезUTF / 10), РазмерФайлаБезUTF) ;
	
	МассивСтрокШаблонПоиска =	РазложитьТекстВМассивСтрок(ВРег(Форма.СтрокаПоиска)," ");
	
	// Заказан поиск в терминах СУБД.
	Если ПоискВТерминахСУБД Тогда
		// Конвертируем поисковые фразы в термины СУБД.
		// Было , например, "Контрагенты", должно стать "Reference145".
		КонвертироватьИмена1СВИменаТаблицСУБД(МассивСтрокШаблонПоиска,Форма.АдресВХранилищеСтруктураХраненияБазыДанных);
	КонецЕсли;
	
	НоваяСтрока = Неопределено;  ТекстИзФайла=Неопределено;
	
	ТаблицаСтрок.Очистить();
	
	ЧтениеФайла = Новый ЧтениеТекста(Файл.ПолноеИмя,,,,Ложь);
	
	ОбрабатываемыйТекст = "";КонОстатокТекста = "";
	
	Работаем = Истина;Итерация = 0;
	
	Пока Работаем Цикл
		
		Если ОтображатьПервыеИлиПоследние = 0 Тогда // Отображать Первые N записей
			
			СтрокаИзФайла = ЧтениеФайла.Прочитать(ПорцияДанныхДляЧтения+1);
			ТекстИзФайла  = КонОстатокТекста + ?(СтрокаИзФайла  = Неопределено, "", СтрокаИзФайла);
			КонОстатокТекста = "";
			
			Если ТекстИзФайла=Неопределено ИЛИ ПустаяСтрока(ТекстИзФайла) Тогда  Прервать;		КонецЕсли;
			
			ВсегоСимволов = СтрДлина(ТекстИзФайла);
			
			
			Позиция1 = -1;Позиция2 = -1;
			
			Для СчетчикСимволов=1 По ВсегоСимволов Цикл	
				Если Сред(ТекстИзФайла,СчетчикСимволов,1)=":" Тогда	
					Если Сред(ТекстИзФайла,СчетчикСимволов+3,1)="." Тогда	
						Если Позиция1=-1 Тогда	
							Позиция1=СчетчикСимволов-2;
						Иначе Позиция2=СчетчикСимволов-2;
							Если Позиция1 > 0 И Позиция2 > 0 Тогда 
								СтрокаТекста = Сред(ТекстИзФайла,Позиция1,Позиция2-Позиция1);
								Если НЕ ПустаяСтрока(СтрокаТекста) Тогда 
									Если  ПроверитьСтрокаСоответствуетУсловиям(МассивСтрокШаблонПоиска,СтрокаТекста, СтруктураУсловийПоиска ) Тогда 
										ТаблицаСтрок.Добавить().Значение = СтрокаТекста;
										Если ТаблицаСтрок.Количество() >= КолВоСтрокДляОтображения Тогда 
											Работаем = Ложь;
											Прервать;
										КонецЕсли;
									КонецЕсли;
								КонецЕсли;
							КонецЕсли;
							Позиция1 = Позиция2;Позиция2 = -1;
						КонецЕсли;
					КонецЕсли;
				КонецЕсли;
			КонецЦикла;
			
			Если Работаем И Позиция1>1 Тогда
				КонОстатокТекста = Сред(ТекстИзФайла,Позиция1);
			КонецЕсли;
			
		КонецЕсли;
		
		Если ОтображатьПервыеИлиПоследние = 1 Тогда // Отображать Последние N записей
			
			Итерация = Итерация  + 1;
			
			Если РазмерФайлаБезUTF - (Итерация * ПорцияДанныхДляЧтения) >=0 Тогда
				ЧтениеФайла = Новый ЧтениеТекста(Файл.ПолноеИмя,,,,Ложь);
				УстановитьНачалоПозицииЧтения(ЧтениеФайла, РазмерФайлаБезUTF - (Итерация * ПорцияДанныхДляЧтения) );
			Иначе 
				Прервать;
			КонецЕсли;
			
			СтрокаИзФайла = ЧтениеФайла.Прочитать( ПорцияДанныхДляЧтения );
			ТекстИзФайла = Неопределено;
			ТекстИзФайла  = ?(СтрокаИзФайла  = Неопределено, "", СтрокаИзФайла) + КонОстатокТекста;
			СтрокаИзФайла = Неопределено;
			КонОстатокТекста = "";
			
			Если ТекстИзФайла=Неопределено ИЛИ ПустаяСтрока(ТекстИзФайла) Тогда
				Прервать;
			КонецЕсли;
			
			ВсегоСимволов = СтрДлина(ТекстИзФайла);
			
			Позиция1 = -1;Позиция2 = ВсегоСимволов;
			
			Для СчетчикСимволов = -ВсегоСимволов По -1 Цикл 
				Если Сред(ТекстИзФайла,-СчетчикСимволов,1)=":" Тогда
					Если Сред(ТекстИзФайла,-СчетчикСимволов+3,1)="." Тогда 
						Позиция1 = -СчетчикСимволов-2;
						Если Позиция1 > 0 И Позиция2 > 0 Тогда	
							СтрокаТекста = Сред(ТекстИзФайла,Позиция1,Позиция2-Позиция1);	
							Если НЕ ПустаяСтрока(СтрокаТекста) Тогда 
								Если  ПроверитьСтрокаСоответствуетУсловиям(МассивСтрокШаблонПоиска,СтрокаТекста, СтруктураУсловийПоиска ) Тогда 
									ТаблицаСтрок.Вставить(0).Значение = СтрокаТекста;Если ТаблицаСтрок.Количество() >= КолВоСтрокДляОтображения Тогда 
										Работаем = Ложь;
										Прервать;
									КонецЕсли;
								КонецЕсли;
							КонецЕсли;
							Позиция2 = Позиция1;Позиция1 = -1;
						КонецЕсли;
					КонецЕсли;
				КонецЕсли;
			КонецЦикла;
			
			Если Работаем И Позиция2 > 1 Тогда
				КонОстатокТекста = Лев(ТекстИзФайла,Позиция2-1);
			КонецЕсли;
			
		КонецЕсли;	
		
	КонецЦикла; 
	
	Для СчетчикСимволов=1 По  ТаблицаСтрок.Количество() Цикл	ТаблицаСтрок[СчетчикСимволов-1].НомерСтроки = СчетчикСимволов;	КонецЦикла;
	
	ЧтениеФайла.Закрыть();
	ЧтениеФайла = Неопределено;ТекстДок = Неопределено;Файл = Неопределено;
	
КонецПроцедуры

// Включает запись логов технологического журнала.
//
Процедура ЗапускТехнологическогоЖурнала(ПараметрыТехнологическогоЖурнала, РезультатВключения) 
	
	КаталогКонфигурацииПриложения = ПутьККонфигурационномуФайлу();
	
	Если КаталогКонфигурацииПриложения <> Неопределено Тогда 
		Если ФайлКонфигурацииСуществует(КаталогКонфигурацииПриложения) Тогда 
			ПереместитьФайл(КаталогКонфигурацииПриложения + ПолучитьРазделительПути() + "logcfg.xml", КаталогКонфигурацииПриложения + ПолучитьРазделительПути() + "logcfg.off");
		КонецЕсли;
		
		КаталогВременныхФайлов = КаталогВременныхФайлов();
		СоздатьКаталог(КаталогВременныхФайлов + "1c_logs");
		ЛокальныйКаталогСЛогФайлами = КаталогВременныхФайлов + "1c_logs\";
		
		ЛогФайлыДляУдаления = НайтиФайлы(ЛокальныйКаталогСЛогФайлами, "*.log", Истина);
		Для каждого Файл Из ЛогФайлыДляУдаления Цикл 
			Попытка
				УдалитьФайлы(Файл.ПолноеИмя);
			Исключение
				// Удаление файла log вызвало ошибку (нет прав, файл уже не существует).
			КонецПопытки;
		КонецЦикла;
		
		Текст = ПолучитьИзВременногоХранилища(ПараметрыТехнологическогоЖурнала.АдресВХранилищеConfigLogФайла );
		УстановитьКаталоЛоговСервера(Текст,ЛокальныйКаталогСЛогФайлами);
		
		УдалитьИзВременногоХранилища(ПараметрыТехнологическогоЖурнала.АдресВХранилищеConfigLogФайла);
		
		ПолныйПутьКонфигурационногоФайла = КаталогКонфигурацииПриложения + ПолучитьРазделительПути() + "logcfg.xml";
		Попытка
			Файл = Новый ЗаписьТекста(ПолныйПутьКонфигурационногоФайла);
			Файл.ЗаписатьСтроку(Текст);
			Файл.Закрыть();
		Исключение
			РезультатВключения.Результат = Ложь;
			РезультатВключения.Причина = НСтр("ru = 'Ошибка создания конфигурационного файла в каталоге'") + " " + КаталогКонфигурацииПриложения + Символы.ПС + НСтр("ru = 'Проверьте права доступа.'");
		КонецПопытки;
		
		ЛокальныйИдентификаторПроцессаОС = ПолучитьИдентификаторПроцессаОС();
		ПараметрыТехнологическогоЖурнала.КаталогСЛогФайлами =  ЛокальныйКаталогСЛогФайлами;
		ПараметрыТехнологическогоЖурнала.ИдентификаторПроцессаОС = Формат(ЛокальныйИдентификаторПроцессаОС, "ЧРД=;ЧРГ=;ЧГ=0");
	КонецЕсли;
	
КонецПроцедуры

Функция ВключениеТехнологическогоЖурнала(Форма) Экспорт
	РезультатВключения = Новый Структура("Результат, Причина", Истина, "");
	
	Если СозданиеТехнологическогоЖурналаВозможно() Тогда
		
		Если  ЭтоАдресВременногоХранилища(Форма.АдресВХранилищеConfigLogФайла)  Тогда
			АдресВХранилищеConfigLogФайла = Форма.АдресВХранилищеConfigLogФайла;
		Иначе
			
			ConfigLogXMLШтатный =  ПолучитьМакет("ConfigLogXMLШтатный");
			АдресВХранилищеConfigLogФайла = ПоместитьВоВременноеХранилище(ConfigLogXMLШтатный.ПолучитьТекст(), Новый УникальныйИдентификатор);
			ConfigLogXMLШтатный = Неопределено;
			
		КонецЕсли;
		
		ПараметрыТехнологическогоЖурнала = Новый Структура("АдресВХранилищеConfigLogФайла ,КаталогСЛогФайлами, ИдентификаторПроцессаОС",АдресВХранилищеConfigLogФайла );
		ЗапускТехнологическогоЖурнала(ПараметрыТехнологическогоЖурнала, РезультатВключения);
		Если РезультатВключения.Результат Тогда
			Форма.Объект.ИдентификаторПроцессаОС = ПараметрыТехнологическогоЖурнала.ИдентификаторПроцессаОС;
			Форма.Объект.КаталогСЛогФайлами = ПараметрыТехнологическогоЖурнала.КаталогСЛогФайлами;
		КонецЕсли;
	Иначе
		РезультатВключения.Результат = Ложь;
		РезультатВключения.Причина = НСтр("ru = 'Запись логов технологического журнала доступна только при работе на ОС Windows.'");
	КонецЕсли;
	
	Возврат РезультатВключения;
КонецФункции

// Функция получает на сервере файл логов , помещает его во временное хранилище
// и возвращает ссылку на файл в хранилище. 
Функция ПолучитьФайлыЛоговССервера(ЛокальныйКаталогСЛогФайлами,ЛокальныйИдентификаторПроцессаОС) Экспорт
	
	АдресФайлаЖурналаВХранилище = Неопределено;
	ПолноеИмяФайлаЖурнала =   ФайлТехнологическийЖурнал(ЛокальныйИдентификаторПроцессаОС, ЛокальныйКаталогСЛогФайлами);
	
	Если ПолноеИмяФайлаЖурнала <> Неопределено И НЕ ПустаяСтрока(ПолноеИмяФайлаЖурнала) Тогда
		
		Попытка
			
			ИмяВременногоАрхивногоФайла = ПолучитьИмяВременногоФайла("zip");
			
			АрхивныйФайл = Новый ЗаписьZipФайла(ИмяВременногоАрхивногоФайла,,,, УровеньСжатияZIP.Максимальный);
			АрхивныйФайл.Добавить( ПолноеИмяФайлаЖурнала);
			АрхивныйФайл.Записать();
			
			
			ДвоичныеДанныеФайла = Новый ДвоичныеДанные( ИмяВременногоАрхивногоФайла );
			АдресФайлаЖурналаВХранилище = ПоместитьВоВременноеХранилище( ДвоичныеДанныеФайла , Новый УникальныйИдентификатор);
			
			УдалитьФайлы( ИмяВременногоАрхивногоФайла );
			
		Исключение
			ПоказатьСообщениеПользователю(ОписаниеОшибки());
		КонецПопытки;
		
		Попытка
			УдалитьФайлы( ИмяВременногоАрхивногоФайла );
		Исключение
		КонецПопытки;
		
	КонецЕсли;
	
	Возврат АдресФайлаЖурналаВХранилище ;
	
КонецФункции

// Функция возвращает Полный путь к файлу логов.
Функция ФайлТехнологическийЖурнал(ЛокальныйИдентификаторПроцессаОС, ЛокальныйКаталогСЛогФайлами)
	
	ОжидаемоеИмяФайла =  ИмяФайлТехнологическийЖурнал(ТекущаяДатаСеанса());
	
	ПолноеИмяФайлаЖурнала  =  НайтиФайлТехнологическийЖурнал(ОжидаемоеИмяФайла, ЛокальныйИдентификаторПроцессаОС, ЛокальныйКаталогСЛогФайлами);
	Если ЗначениеЗаполнено(ПолноеИмяФайлаЖурнала) Тогда 
		Возврат ПолноеИмяФайлаЖурнала;
	Иначе
		ОжидаемоеИмяФайла = ИмяФайлТехнологическийЖурнал(ТекущаяДатаСеанса() - 3600);
		ПолноеИмяФайлаЖурнала  =  НайтиФайлТехнологическийЖурнал(ОжидаемоеИмяФайла, ЛокальныйИдентификаторПроцессаОС, ЛокальныйКаталогСЛогФайлами);
		Если ЗначениеЗаполнено(ПолноеИмяФайлаЖурнала) Тогда 
			Возврат ПолноеИмяФайлаЖурнала;
		КонецЕсли;
	КонецЕсли;
	
	Возврат Неопределено;
	
КонецФункции

// Функция производит поиск файла лога нашего процесса.
Функция НайтиФайлТехнологическийЖурнал(ИмяФайла, ЛокальныйИдентификаторПроцессаОС, ЛокальныйКаталогСЛогФайлами)
	
	СписокФайлов = НайтиФайлы(ЛокальныйКаталогСЛогФайлами, "*.log", Истина);
	Для каждого Файл Из СписокФайлов Цикл
		Если Найти(Файл.Путь, "_" + ЛокальныйИдентификаторПроцессаОС) > 0 Тогда
			Если Файл.Имя = ИмяФайла Тогда 
				Возврат Файл.ПолноеИмя;
			КонецЕсли;
		КонецЕсли;
	КонецЦикла;
	
	Возврат Неопределено;
	
КонецФункции

// Функция возвращает ожидаемое имя файла.
Функция ИмяФайлТехнологическийЖурнал(ДатаФайла)
	ОжидаемоеИмяФайла = Формат(ДатаФайла, "ДФ=yyMMddHH")+ ".log";
	Возврат ОжидаемоеИмяФайла;
КонецФункции

// Выключает технологический журнал.
//
Процедура ВыключениеТехнологическогоЖурнала(ЛокальныйИдентификаторПроцессаОС, ЛокальныйКаталогСЛогФайлами) Экспорт
	КаталогКонфигурацииПриложения = ПутьККонфигурационномуФайлу();
	Если КаталогКонфигурацииПриложения <> Неопределено Тогда 
		УдалитьФайлы(КаталогКонфигурацииПриложения + ПолучитьРазделительПути() + "logcfg.xml");
	КонецЕсли;
	
	СтарыйФайлКонфигурации = Новый Файл(КаталогКонфигурацииПриложения + ПолучитьРазделительПути() + "logcfg.off");
	Если СтарыйФайлКонфигурации.Существует() Тогда 
		ПереместитьФайл(КаталогКонфигурацииПриложения + ПолучитьРазделительПути() + "logcfg.off", КаталогКонфигурацииПриложения + ПолучитьРазделительПути() + "logcfg.xml");
	КонецЕсли;
	
КонецПроцедуры

// Функция определяет по наличию файла конфигурации технологического журнала, 
// ведется ли запись логов технологического журнала.
Функция ВедетсяЗаписьЛоговТехнологическогоЖурнала() Экспорт	
	
	ТехнологическийЖурналРаботает = Ложь;
	
	КаталогКонфигурацииПриложения = ПутьККонфигурационномуФайлу();
	
	ФайлКонфигурации = Новый Файл(КаталогКонфигурацииПриложения + ПолучитьРазделительПути() + "logcfg.xml");
	
	Если ФайлКонфигурации.Существует() Тогда 
		ТехнологическийЖурналРаботает = Истина;
	КонецЕсли;
	
	Возврат ТехнологическийЖурналРаботает;
	
КонецФункции


#КонецОбласти

#Область ВспомогательныеФункции

// Функция возвращает расширение файла.
Функция ПолучитьРасширениеФайла(Знач ИмяФайла)
	
	ПозицияТочки = 0;
	
	Пока Истина Цикл
		ПозицияТочки=Найти(ИмяФайла,".");
		Если ПозицияТочки = 0 Тогда
			Прервать;
		Иначе
			ИмяФайла=Сред(ИмяФайла,ПозицияТочки + 1);
		КонецЕсли;
	КонецЦикла;
	
	Возврат ИмяФайла;
	
КонецФункции

Функция ПроверитьСтрокаСоответствуетУсловиям(МассивЧтоИщем,ПроверяемаяСтрока, СтруктураПараметровУсловий )
	
	УсловиеСоблюдается = Ложь;
	
	Если МассивЧтоИщем.Количество()>0 Тогда
		
		// Сбрасываем флаг успешности поиска поиска.
		СтрокаУдовлетворяетПоисковомуЗапросу = Ложь;
		// Перебираем все фрагменты строки поиска на предмет их поиска в искомом выражении.
		Для каждого ЧтоИщем Из МассивЧтоИщем Цикл
			
			Если ПустаяСтрока(ЧтоИщем) Тогда	Продолжить;		КонецЕсли;
			
			Если Найти(ВРег(ПроверяемаяСтрока),ВРег(ЧтоИщем) )>0 Тогда
				// Фрагмент строки найден.
				
				// Применяем установленные логические операции.
				Если СтруктураПараметровУсловий.Лог_ИЛИ Тогда
					СтрокаУдовлетворяетПоисковомуЗапросу = Истина;
					Прервать;
				КонецЕсли;
				
				СтрокаУдовлетворяетПоисковомуЗапросу = Истина;
				
			Иначе	
				
				Если СтруктураПараметровУсловий.Лог_И Тогда
					СтрокаУдовлетворяетПоисковомуЗапросу = Ложь;
					Прервать;
				КонецЕсли;
				
			КонецЕсли;
			
		КонецЦикла;
		
		// Инвертируем успешность поиска , если установлен флаг.
		Если СтруктураПараметровУсловий.Лог_НЕ Тогда
			СтрокаУдовлетворяетПоисковомуЗапросу = НЕ СтрокаУдовлетворяетПоисковомуЗапросу ;
		КонецЕсли;
		
		Если СтрокаУдовлетворяетПоисковомуЗапросу Тогда
			УсловиеСоблюдается = Истина;
		КонецЕсли;
		
	Иначе
		УсловиеСоблюдается = Истина;
	КонецЕсли;
	
	Если УсловиеСоблюдается=Истина И (Не ПустаяСтрока(СтруктураПараметровУсловий.ИнтервалВремениОт) ИЛИ НЕ ПустаяСтрока(СтруктураПараметровУсловий.ИнтервалВремениДо)) Тогда
		СтрокаСравнения = Лев(ПроверяемаяСтрока,12);
		УсловиеСоблюдается = ( ПустаяСтрока(СтруктураПараметровУсловий.ИнтервалВремениОт) ИЛИ (Не ПустаяСтрока(СтруктураПараметровУсловий.ИнтервалВремениОт) И СтруктураПараметровУсловий.ИнтервалВремениОт <= СтрокаСравнения) )
		И ( ПустаяСтрока(СтруктураПараметровУсловий.ИнтервалВремениДо) ИЛИ (Не ПустаяСтрока(СтруктураПараметровУсловий.ИнтервалВремениДо) И СтрокаСравнения <= СтруктураПараметровУсловий.ИнтервалВремениДо) );
	КонецЕсли;
	
	Возврат УсловиеСоблюдается;
	
КонецФункции

// Возвращает массив фраз Из строки, с заданным разделителем фраз.
// 
Функция РазложитьТекстВМассивСтрок(Знач Текст=  "", Разделитель = "")
	
	Текст = СтрЗаменить(Текст, "  "," ");
	Текст = СтрЗаменить(Текст, "  "," ");
	
	МассивСтрок = Новый Массив;
	
	Пока СтрДлина(Текст)>0 Цикл
		Позиция = Найти(Текст, Разделитель);
		Если Позиция=0 Тогда
			Позиция = СтрДлина(Текст)+1;
		КонецЕсли;
		МассивСтрок.Добавить(Лев(Текст,Позиция-1));
		Текст = Сред(Текст,Позиция+1);
	КонецЦикла;
	
	Возврат МассивСтрок;
	
КонецФункции


// Функция проверяет, есть уже файл конфигурации технологического журнала на сервере.
Функция ФайлКонфигурацииСуществует(ПутьКФайлуКонфигурации)
	ФайлКонфигурации = Новый Файл(ПутьКФайлуКонфигурации + ПолучитьРазделительПути() + "logcfg.xml");
	Если ФайлКонфигурации.Существует() Тогда 
		ФайлТекстаКонфигурации = Новый ЧтениеТекста(ФайлКонфигурации.ПолноеИмя);
		СтрокаТекстКонфигурации = ФайлТекстаКонфигурации.ПрочитатьСтроку();
		Пока СтрокаТекстКонфигурации <> Неопределено Цикл
			Если Найти(СтрокаТекстКонфигурации, "ConsoleQueries") > 0 Тогда 	
				Возврат Ложь;
			КонецЕсли;
			СтрокаТекстКонфигурации = ФайлТекстаКонфигурации.ПрочитатьСтроку();
		КонецЦикла;
		Возврат Истина;
	КонецЕсли;
	
	Возврат Ложь;
	
КонецФункции


// Определяет и возвращает идентификатор процесса ОС.
// Нужен для определения где логи нашего процесса, а где чужих процессов.
Функция ПолучитьИдентификаторПроцессаОС() Экспорт
	
	ИДТекущегоПроцесса = Неопределено;
	ОбъектСистемы = Новый COMОбъект("WScript.Shell");
	Если ИДТекущегоПроцесса = Неопределено Тогда 
		Процесс = ОбъектСистемы.Exec("rundll32.exe kernel32,Sleep");
		ИДТекущегоПроцесса = ПолучитьCOMОбъект("winmgmts:{impersonationLevel=impersonate}!\\.\root\CIMV2:Win32_Process.Handle='" + Формат(Процесс.ProcessID,"ЧГ=0") + "'").ParentProcessID;
		Процесс.Terminate();
	КонецЕсли;
	
	Возврат ИДТекущегоПроцесса;
	
КонецФункции 

// Производит замену шаблонного пути,где должен быть создан технологический журнал, 
// указанного в файле настройки, на реальный существующий каталог.
Процедура УстановитьКаталоЛоговСервера(Текст,ЛокальныйКаталогСЛогФайлами)
	
	ИскомаяФразаНачала = "location=";
	
	Позиция = Найти(Текст,ИскомаяФразаНачала);
	Если Позиция>0 Тогда
		СчетчикКавычек = 0;
		Позиция= Позиция+ СтрДлина(ИскомаяФразаНачала);
		
		НачальнаяПозиция = Позиция;
		Пока Позиция <= СтрДлина(Текст) И СчетчикКавычек < 2 Цикл
			Если Сред(Текст,Позиция,1)="""" Тогда
				СчетчикКавычек = СчетчикКавычек + 1;
			КонецЕсли;
			Позиция=Позиция+1
		КонецЦикла;
		
		Если СчетчикКавычек = 2 Тогда
			Текст = Лев(Текст, НачальнаяПозиция)+ЛокальныйКаталогСЛогФайлами + Сред(Текст, Позиция-1) ;
		КонецЕсли;
	КонецЕсли;
	
КонецПроцедуры

// Функция проверяет, возможна ли вообще функция создания технологического журнала.
// Проверяется, на какой ОС запущена программа.
Функция СозданиеТехнологическогоЖурналаВозможно()
	
	СистемнаяИнформация = Новый СистемнаяИнформация();
	Если (СистемнаяИнформация.ТипПлатформы = ТипПлатформы.Windows_x86) ИЛИ (СистемнаяИнформация.ТипПлатформы = ТипПлатформы.Windows_x86_64) Тогда
		Возврат Истина;
	КонецЕсли;
	
	Возврат Ложь;
	
КонецФункции 

// Возвращает структуру хранения БД в виде таблицы значений.
// 
Функция ПолучитьОписаниеХраненияБД()  Экспорт
	
	СтруктураХраненияБД=ПолучитьСтруктуруХраненияБазыДанных();
	СтруктураХраненияБД.Колонки.Добавить("КраткоеИмя",Новый ОписаниеТипов("Строка",Новый КвалификаторыСтроки(100)));
	СтруктураХраненияБД.Индексы.Добавить("КраткоеИмя");
	
	Для каждого СтрокаХранения Из СтруктураХраненияБД Цикл 		СтрокаХранения.КраткоеИмя = ВРег(Сред(СтрокаХранения.Метаданные, Найти(СтрокаХранения.Метаданные,".")+1));КонецЦикла; 
	
	СтруктураХраненияБД.Сортировать("ИмяТаблицыХранения Убыв");
	Возврат  ПоместитьВоВременноеХранилище( СтруктураХраненияБД, Новый УникальныйИдентификатор);
	
КонецФункции

// Заполняет структуру хранения БД в виде дерева, с указанием всех используемых полей. 
// 
Процедура ЗаполнитьДеревоСтруктурыХраненияБД(Деревцо, АдресВХранилищеСтруктураХраненияБазыДанных ) Экспорт
	
	СтруктураХраненияБД = ПолучитьИзВременногоХранилища( АдресВХранилищеСтруктураХраненияБазыДанных );
	
	Если ТипЗнч(СтруктураХраненияБД) <> Тип("ТаблицаЗначений") Тогда
		Возврат;
	КонецЕсли;
	
	Для каждого СтрокаХранения Из СтруктураХраненияБД Цикл
		
		ГлавнаяСтрокаДерева = Деревцо.Строки.Добавить();
		ГлавнаяСтрокаДерева.ИмяОбъекта = СтрокаХранения.ИмяТаблицы;
		ГлавнаяСтрокаДерева.ИмяОбъектаХранения = СтрокаХранения.ИмяТаблицыХранения;
		ГлавнаяСтрокаДерева.Назначение = СтрокаХранения.Назначение;
		ГлавнаяСтрокаДерева.Метаданные = СтрокаХранения.Метаданные;
		
		СтрокаПолей = ГлавнаяСтрокаДерева.Строки.Добавить();
		СтрокаПолей.ИмяОбъекта = " Поля";
		
		Для каждого ЭлементПоле Из СтрокаХранения.Поля Цикл
			СтрокаПОля = СтрокаПолей.Строки.Добавить();
			СтрокаПОля.ИмяОбъекта = ЭлементПоле.ИмяПоля;
			СтрокаПОля.ИмяОбъектаХранения = ЭлементПоле.ИмяПоляХранения;
			СтрокаПОля.Метаданные = ЭлементПоле.Метаданные;
		КонецЦикла;
		
		
		СтрокаИндексов = ГлавнаяСтрокаДерева.Строки.Добавить();
		СтрокаИндексов.ИмяОбъекта = "Индексы";
		
		Для каждого ЭлементПоле Из СтрокаХранения.Индексы Цикл
			СтрокаПОля = СтрокаИндексов.Строки.Добавить();
			СтрокаПОля.ИмяОбъектаХранения = ЭлементПоле.ИмяИндексаХранения;
			
			Для каждого ЭлементПолеИндекса Из ЭлементПоле.Поля Цикл
				СтрокаПОляИндекса = СтрокаПОля.Строки.Добавить();
				СтрокаПОляИндекса.ИмяОбъекта = ЭлементПолеИндекса.ИмяПоля;
				СтрокаПОляИндекса.ИмяОбъектаХранения = ЭлементПолеИндекса.ИмяПоляХранения;
				СтрокаПОляИндекса.Метаданные = ЭлементПолеИндекса.Метаданные;
			КонецЦикла;
			
		КонецЦикла;
	КонецЦикла;
	
КонецПроцедуры

Процедура ПоказатьСообщениеПользователю(ТекстСообщения,ИмяПоля=Неопределено)
	
	Сообщение = Новый СообщениеПользователю;
	Сообщение.Текст = ТекстСообщения;
	Если ИмяПоля <> Неопределено Тогда
		Сообщение.Поле = ИмяПоля;
	КонецЕсли;
	
	Сообщение.Сообщить();
	
КонецПроцедуры 

#КонецОбласти

#КонецЕсли