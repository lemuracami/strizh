#Область Обработчики_событий_и_команд


&НаКлиенте
Процедура ПолучитьТокен(Команда)
	ПоместитьJSONвХранилище();
	ПолучитьТокенНаСервере();
КонецПроцедуры


&НаКлиенте
Процедура ОтправитьВГугл(Команда)
	Если токен = "" или истекает<ТекущаяДата() Тогда
		Сообщить("Нажмите кнопку ""Получить токен""");
		Возврат;
	КонецЕсли;
	
	ТекСтолбец = ТабДок.ТекущаяОбласть.Лево;
	ОтправитьНаГуглШит(ТекСтолбец);
КонецПроцедуры

&НаКлиенте
Процедура РазобратьСертификат(Команда)
	
	ПоместитьJSONвХранилище();
	ПолучитьСтруктуруСертификата();
	ЭтаФорма.ТекущийЭлемент = Элементы.ПарсСертификатаJson;
	
КонецПроцедуры

&НаКлиенте
Процедура ПриОткрытии(Отказ)
	Если истекает < ТекущаяДата() Тогда
		истекает = Дата(1,1,1);
		токен = "";
	КонецЕсли;
КонецПроцедуры

&НаКлиенте
Процедура ПутьКлючаJsonНачалоВыбора(Элемент, ДанныеВыбора, СтандартнаяОбработка)
	СтандартнаяОбработка = Ложь;
	РежимДиалога = РежимДиалогаВыбораФайла.Открытие;
	ДиалогВыбораФайла = Новый ДиалогВыбораФайла(РежимДиалога);
	ДиалогВыбораФайла.ПроверятьСуществованиеФайла = Истина;
	ДиалогВыбораФайла.МножественныйВыбор = Ложь;
	ДиалогВыбораФайла.Заголовок = Нстр("ru = 'Укажите файл ключа JSON для загрузки'");
	ДиалогВыбораФайла.ПолноеИмяФайла = Элемент.ТекстРедактирования;
	ДиалогВыбораФайла.Фильтр = "Файл json(*.json)|*.json";
	
	ДиалогВыбораФайла.Показать(Новый ОписаниеОповещения("ПутьКлючаJsonНачалоВыбораЗавершение", ЭтаФорма, Новый Структура("ДиалогВыбораФайла", ДиалогВыбораФайла)));

КонецПроцедуры

&НаКлиенте
Процедура ПутьКлючаJsonНачалоВыбораЗавершение(ВыбранныеФайлы, ДополнительныеПараметры) Экспорт
	
	ДиалогВыбораФайла = ДополнительныеПараметры.ДиалогВыбораФайла;
	
	
	Если (ВыбранныеФайлы <> Неопределено) Тогда
		ПутьФайлаКлючаJson = ДиалогВыбораФайла.ПолноеИмяФайла; 
	КонецЕсли;

КонецПроцедуры

&НаКлиенте
Процедура ПоместитьJSONвХранилище()
	
	Если ПутьФайлаКлючаJson<>"" Тогда
		ФайлДвоичныеДанные = Новый ДвоичныеДанные(ПутьФайлаКлючаJson);
		АдресХранилищаКлючаJSON = ПоместитьВоВременноеХранилище(ФайлДвоичныеДанные, УникальныйИдентификатор);
	Иначе
		АдресХранилищаКлючаJSON = "";
	КонецЕсли;
	
КонецПроцедуры


#КонецОбласти


#Область СлужебныеПроцедурыИФункции

&НаСервере
Процедура ПолучитьТокенНаСервере()
	
	СтруктураСертификата = ПолучитьСтруктуруСертификата();
	
	//Создаем base64url header+clameset for jwt
	//https://developers.google.com/identity/protocols/OAuth2ServiceAccount 
	//на странице ↑ найти и кликнуть HTTP/REST, чтоб увидеть алгоритм формирования подписи без использования гуглбиблиотек

	//хедер всегда одинаковый, можно сразу base64урл,
	//eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCJ9
	//здесь проделано для сверки с примером
	//The Base64url representation of this is as follows:
	
	СтруктураДляЖсон = Новый Структура;
	СтруктураДляЖсон.Вставить("alg", "RS256");
	СтруктураДляЖсон.Вставить("typ", "JWT");
	жсон = Новый ЗаписьJson;
	жсон.УстановитьСтроку(Новый ПараметрыЗаписиJSON(ПереносСтрокJSON.Нет));
	ЗаписатьJSON(жсон, СтруктураДляЖсон);
	СтрокаЖсонХедер = жсон.Закрыть();
	
	Хедер64 = Base64Url(ПолучитьДвоичныеДанныеИзСтроки(СтрокаЖсонХедер));
	
	СтруктураДляЖсон.Очистить();
	
	//iss 	The email address of the service account.
	СтруктураДляЖсон.Вставить("iss", СтруктураСертификата.client_email);
	
	//scope 	A space-delimited list of the permissions that the application requests.
	//смотреть какой скоп нужен например: https://developers.google.com/sheets/api/guides/authorizing
	СтруктураДляЖсон.Вставить("scope", "https://www.googleapis.com/auth/spreadsheets");
	
	//aud 	A descriptor of the intended target of the assertion. 
	//When making an access token request this value is always https://www.googleapis.com/oauth2/v4/token.
	СтруктураДляЖсон.Вставить("aud", "https://www.googleapis.com/oauth2/v4/token");
	
	//exp 	The expiration time of the assertion, specified as seconds since 00:00:00 UTC, January 1, 1970. 
	//This value has a maximum of 1 hour after the issued time.
	ВремяИстеченияUTC = УниверсальноеВремя(ТекущаяДата())+60*60;
	СекундДо = ВремяИстеченияUTC - Дата(1970,1,1);
	СтруктураДляЖсон.Вставить("exp", СекундДо);
	
	//iat 	The time the assertion was issued, specified as seconds since 00:00:00 UTC, January 1, 1970.
	СтруктураДляЖсон.Вставить("iat", СекундДо-60*60);
	
	жсон = Новый ЗаписьJson;
	жсон.УстановитьСтроку(Новый ПараметрыЗаписиJSON(ПереносСтрокJSON.Нет));
	ЗаписатьJSON(жсон, СтруктураДляЖсон);
	СтрокаЖсонКлэймСет = жсон.Закрыть();
	
	КлэймСет64 = Base64Url(ПолучитьДвоичныеДанныеИзСтроки(СтрокаЖсонКлэймСет));
	JWTдляСигнатуры = Хедер64+"."+КлэймСет64;
	
	Хеширование = Новый ХешированиеДанных(ХешФункция.SHA256);
	Хеширование.Добавить(JWTдляСигнатуры);
	ХешДвоичный = Хеширование.ХешСумма;
	
	//ОбработкаОбъект = РеквизитФормыВЗначение("Объект");
	//МакетПодписи = ОбработкаОбъект.ПолучитьМакет("Макет");
	//ХМЛТекст = ПолучитьСтрокуИзДвоичныхДанных(МакетПодписи);
	//КриптоПровайдер = Новый COMОбъект("System.Security.Cryptography.RSACryptoServiceProvider");
	//КриптоПровайдер.FromXmlString(ХМЛТекст);
	//
	//SafeArrayBinХешДляПодписи = SafeИзДвоичных(ХешДвоичный);
	//SafeArrayBinПодписьДвоичная = КриптоПровайдер.SignHash(SafeArrayBinХешДляПодписи, "SHA256");
	//ПодписьДвоичная = ДвоичныеИзSafe(SafeArrayBinПодписьДвоичная);
	
	ПодписьДвоичная = ПолучиьПодписьSHA256RSA(ХешДвоичный, СтруктураСертификата);
	Подпись64 = Base64Url(ПодписьДвоичная);
	
	JWT = JWTдляСигнатуры + "."+Подпись64;
	
	OpenSSL = Новый ЗащищенноеСоединениеOpenSSL();
	HTTPСоединение = Новый HTTPСоединение("www.googleapis.com",,,,,,OpenSSL);
	Заголовки = Новый Соответствие;
 	Заголовки.Вставить("Content-Type", "application/x-www-form-urlencoded");
	grant_type = КодироватьСтроку("urn:ietf:params:oauth:grant-type:jwt-bearer",СпособКодированияСтроки.КодировкаURL);
	HTTPЗапрос = Новый HTTPЗапрос("/oauth2/v4/token", Заголовки);
	HTTPЗапрос.УстановитьТелоИзСтроки("grant_type="+grant_type+"&assertion="+JWT);
	HTTPОтвет = HTTPСоединение.ОтправитьДляОбработки(HTTPЗапрос);
	
	ТелоОтвета = HTTPОтвет.ПолучитьТелоКакСтроку();
	
	Если HTTPОтвет.КодСостояния <> 200 Тогда
		Сообщить("Токен не получен, сервер вернул:");
		Сообщить(ТелоОтвета);
		Возврат;
	КонецЕсли;
	
	жсон = Новый ЧтениеJSON;
	жсон.УстановитьСтроку(ТелоОтвета);
	Попытка
		СтруктураЖсон = ПрочитатьJSON(жсон);
	Исключение
		Сообщить ("Гугл вернул не Жсон: " + ТелоОтвета);
		Возврат;
	КонецПопытки;
	
	Если СтруктураЖсон.Свойство("access_token", токен) Тогда
		истекает = ТекущаяДата() + СтруктураЖсон.expires_in - 10;
	Иначе
		истекает = Неопределено;
	КонецЕсли;
	
	//адрес проверки срока токена
	//https://www.googleapis.com/oauth2/v1/tokeninfo?access_token=ya29.c.ElqEBWsnrQ_EWdMgsoHeEUTyf7s8mrXi6yx2QIeegNShgE4wm-o8i0njsj7mI3GZS1yUphtwIkS7PSUmI9sm2OkNfGYbEcjTdY1biQByhFq2hsRemXtDqlBFlig
	//HTTPЗапрос = Новый HTTPЗапрос("/oauth2/v1/tokeninfo?access_token="+токен, Заголовки);
	//HTTPОтвет = HTTPСоединение.Получить(HTTPЗапрос);
	//жсон = Новый ЧтениеJSON;
	//жсон.УстановитьСтроку(HTTPОтвет.ПолучитьТелоКакСтроку());
	//истекает = Дата(1,1,1);
	//Пока истекает = Дата(1,1,1) Цикл
	//	жсон.Прочитать();
	//	Если жсон.ТипТекущегоЗначения = ТипЗначенияJSON.ИмяСвойства и жсон.ТекущееЗначение = "expires_in" Тогда
	//		жсон.Прочитать();
	//		истекает = ТекущаяДата() + жсон.ТекущееЗначение - 10;//запас 10 секунд
	//		Прервать;
	//	КонецЕсли;
	//КонецЦикла;
	
КонецПроцедуры

&НаСервере	
Процедура ОтправитьНаГуглШит(ТекСтолбец)
	
	АпиАдрес = "/v4/spreadsheets/1H_nu10s9gB787gy4Qhx2bbCyGPrfRnkGGEuZrtV4-0s/values/";
	ИмяЛиста = "ТестовыйЛист";
	ВысотаТаб = ТабДок.ВысотаТаблицы;
	
	
	СтруктураЖсон = Новый Структура;
	ЦелевойАдресА1 = ИмяЛиста + "!"+НотацияА1(1,ТекСтолбец)+":"+НотацияА1(ВысотаТаб,ТекСтолбец);
	СтруктураЖсон.Вставить("range", ЦелевойАдресА1);
	СтруктураЖсон.Вставить("majorDimension", "COLUMNS");
	
	МассивДляСтолбца = Новый Массив;
	Для сч = 1 по ТабДок.ВысотаТаблицы Цикл
		МассивДляСтолбца.Добавить(ТабДок.Область(сч,ТекСтолбец).Текст);
	КонецЦикла;
	МассивДляОбласти = Новый Массив;
	МассивДляОбласти.Добавить(МассивДляСтолбца);
	СтруктураЖсон.Вставить("values", МассивДляОбласти);
	
	жсон = Новый ЗаписьJSON;
	жсон.УстановитьСтроку();
	ЗаписатьJSON(жсон, СтруктураЖсон);
	СтрокаЖсон = жсон.Закрыть();
	
	урл = АпиАдрес + ЦелевойАдресА1 + "?valueInputOption=USER_ENTERED";
	
	OpenSSL = Новый ЗащищенноеСоединениеOpenSSL();
	HTTPСоединение = Новый HTTPСоединение("sheets.googleapis.com",,,,,,OpenSSL);
	Заголовки = Новый Соответствие;
 	Заголовки.Вставить("Content-Type", "application/json; charset=UTF-8");
	Заголовки.Вставить("Authorization", "Bearer " + токен);
	
	HTTPЗапрос = Новый HTTPЗапрос(урл, Заголовки);
	HTTPЗапрос.УстановитьТелоИзСтроки(СтрокаЖсон);
	
	Ответ = HTTPСоединение.Записать(HTTPЗапрос);
	Если Ответ.КодСостояния = 200 Тогда
		Сообщить ("Успешно");
	ИначеЕсли Ответ.КодСостояния = 401 Тогда
		Сообщить ("Токен не принят, получите новый");
	Иначе
		Сообщить (Ответ.ПолучитьТелоКакСтроку());
	КонецЕсли;

//401: Invalid Credentials
//Invalid authorization header. The access token you're using is either expired or invalid.
//{
//  "error": {
//    "code": 401,
//    "message": "Request had invalid authentication credentials. Expected OAuth 2 access token, login cookie or other valid authentication credential. See https://developers.google.com/identity/sign-in/web/devconsole-project.",
//    "status": "UNAUTHENTICATED"
//  }
//}
	
КонецПроцедуры

&НаСервере
//create base64url header + clame for jwt
//https://developers.google.com/identity/protocols/OAuth2ServiceAccount 
//на странице ↑ найти и кликнуть HTTP/REST, чтоб увидеть алгоритм формирования подписи без использования гуглбиблиотек
Функция JWTдляСигнатуры()
	
	//это все время одинаковое, можно сразу base64урл, здесь для сверки с примером
	жсон = Новый ЗаписьJson;
	жсон.УстановитьСтроку(Новый ПараметрыЗаписиJSON(ПереносСтрокJSON.Нет));
	жсон.ЗаписатьНачалоОбъекта();
	жсон.ЗаписатьИмяСвойства("alg");
	жсон.ЗаписатьЗначение("RS256");
	жсон.ЗаписатьИмяСвойства("typ");
	жсон.ЗаписатьЗначение("JWT");
	жсон.ЗаписатьКонецОбъекта();
	СтрокаЖсонХедер = жсон.Закрыть();
	Хедер64 = Base64Url(ПолучитьДвоичныеДанныеИзСтроки(СтрокаЖсонХедер));
	
	жсон = Новый ЗаписьJson;
	жсон.УстановитьСтроку(Новый ПараметрыЗаписиJSON(ПереносСтрокJSON.Нет));
	жсон.ЗаписатьНачалоОбъекта();
	
	//iss 	The email address of the service account.
	жсон.ЗаписатьИмяСвойства("iss");
	жсон.ЗаписатьЗначение("dansserviceaccount@dans-test-project-198115.iam.gserviceaccount.com");
	
	//scope 	A space-delimited list of the permissions that the application requests.
	//смотреть что нужно например: https://developers.google.com/sheets/api/guides/authorizing
	жсон.ЗаписатьИмяСвойства("scope");
	жсон.ЗаписатьЗначение("https://www.googleapis.com/auth/spreadsheets");
	
	//aud 	A descriptor of the intended target of the assertion. 
	//When making an access token request this value is always https://www.googleapis.com/oauth2/v4/token.
	жсон.ЗаписатьИмяСвойства("aud");
	жсон.ЗаписатьЗначение("https://www.googleapis.com/oauth2/v4/token");
	
	//exp 	The expiration time of the assertion, specified as seconds since 00:00:00 UTC, January 1, 1970. 
	//This value has a maximum of 1 hour after the issued time.
	ВремяДо = УниверсальноеВремя(ТекущаяДата())+60*60;
	СекундДо = ВремяДо - Дата(1970,1,1);
	жсон.ЗаписатьИмяСвойства("exp");
	жсон.ЗаписатьЗначение(СекундДо);
	
	//iat 	The time the assertion was issued, specified as seconds since 00:00:00 UTC, January 1, 1970.
	жсон.ЗаписатьИмяСвойства("iat");
	жсон.ЗаписатьЗначение(СекундДо-60*60);
	
	жсон.ЗаписатьКонецОбъекта();
	СтрокаЖсонКлэймСет = жсон.Закрыть();
	КлэймСет64 = Base64Url(ПолучитьДвоичныеДанныеИзСтроки(СтрокаЖсонКлэймСет));
	
	Возврат Хедер64+"."+КлэймСет64;
	
КонецФункции

&НаСервере
// существует изменённый Base64 для URL, где не используется заполнение символом = 
// и символы + и / соответственно заменяются на * и -
// -------- подошел второй ↓ вариант плюс убраны заполнения символом "=" ----------
// Base64-кодирования URL адресов признается вариант, 
// когда символы + и / заменяются, соответственно, на - и _ (RFC 3548, раздел 4). 
Функция Base64Url(ДвоичныеДанные)
	
	бейс64строка = Base64Строка(ДвоичныеДанные);
	бейс64строка = стрЗаменить(бейс64строка, "+", "-");
	бейс64строка = стрЗаменить(бейс64строка, "/", "_");
	бейс64строка = стрЗаменить(бейс64строка, Символы.ВК, "");
	бейс64строка = стрЗаменить(бейс64строка, Символы.ПС, "");
	
	Если Прав(бейс64строка, 2) = "==" Тогда
		бейс64строка = Лев(бейс64строка,СтрДлина(бейс64строка)-2);
		
	ИначеЕсли Прав(бейс64строка, 1) = "=" Тогда
		бейс64строка = Лев(бейс64строка,СтрДлина(бейс64строка)-1);
	КонецЕсли;
	
	Возврат бейс64строка;
	
КонецФункции

//вернет адрес ячейки таблицы в формате А1
//работает только от A до Z
//
&НаСервере
Функция НотацияА1(НомерСтроки, НомерСтолбца)
	//A=65, Z=90, 26 символов на одну букву
	НомерСтолбца = Мин(НомерСтолбца, 26);
	Возврат (Символ(64+НомерСтолбца)+Формат(НомерСтроки,"ЧГ=0"));	
	
КонецФункции

//некорректная работа буфера
Функция Тест()
	Буфер = Новый БуферДвоичныхДанных(3);
	Буфер.Установить(0,255);
	Буфер.Установить(1,255);
	Буфер.Установить(2,255);                             
	хекс = ПолучитьHexСтрокуИзБуфераДвоичныхДанных(Буфер);
	Буфер = ПолучитьБуферДвоичныхДанныхИзHexСтроки(хекс); //тут будет облом в 8.3.10.21.68
	возврат буфер;
КонецФункции

#КонецОбласти


#Область Вместо_криптоменеджеров


&НаСервере
// возвращает структуру свойств сертификата, в т.ч. параметры для вычисления подписи
Функция ПолучитьСтруктуруСертификата()
	
	Если АдресХранилищаКлючаJSON = "" Тогда
		ОбработкаОбъект = РеквизитФормыВЗначение("Объект");
		МакетПодписиДвоичный = ОбработкаОбъект.ПолучитьМакет("JSON");
	Иначе
		МакетПодписиДвоичный = ПолучитьИзВременногоХранилища(АдресХранилищаКлючаJSON);
	КонецЕсли;
		
	СтруктураСертификата = Новый Структура;
	жсон = Новый ЧтениеJSON;
	жсон.УстановитьСтроку(ПолучитьСтрокуИзДвоичныхДанных(МакетПодписиДвоичный));
	Пока жсон.Прочитать() Цикл
		Если жсон.ТипТекущегоЗначения = ТипЗначенияJSON.ИмяСвойства Тогда
			ИмяСвойства = жсон.ТекущееЗначение;
			жсон.Прочитать();
			ЗначениеСвойства =  жсон.ТекущееЗначение;
			СтруктураСертификата.Вставить(ИмяСвойства, ЗначениеСвойства);
		КонецЕсли;
	КонецЦикла;
	РасшаритьДляЕмейла = СтруктураСертификата.client_email;
	
	КлючСтрока = СтруктураСертификата.private_key;
	КлючСтрока = СтрЗаменить(КлючСтрока,"-----BEGIN PRIVATE KEY-----","");
	КлючСтрока = СтрЗаменить(КлючСтрока,"-----END PRIVATE KEY-----","");
	ХексСтрокаКлюча = ПолучитьHexСтрокуИзДвоичныхДанных(Base64Значение(КлючСтрока));
	Тэги = Новый Соответствие;
	Тэги.Вставить("30","SEQUENCE");
	Тэги.Вставить("02","INTEGER");
	Тэги.Вставить("06","OBJECT IDENTIFIER");
	Тэги.Вставить("04","OCTET STRING");
	Тэги.Вставить("05","NULL");
	
	ДлинаАдресаОдинБайт = "81";
	ДлинаАдресаДваБайта = "82";
	
	парс = Новый ДеревоЗначений;
	парс.Колонки.Добавить("Класс",Новый ОписаниеТипов("Строка",,,,Новый КвалификаторыСтроки(2)));
	парс.Колонки.Добавить("ИмяКласса",Новый ОписаниеТипов("Строка"));
	парс.Колонки.Добавить("ПредбайтДлины",Новый ОписаниеТипов("Строка",,,,Новый КвалификаторыСтроки(2)));
	парс.Колонки.Добавить("БайтДлины",Новый ОписаниеТипов("Строка",,,,Новый КвалификаторыСтроки(4)));
	парс.Колонки.Добавить("ДлинаЧисло", Новый ОписаниеТипов("Число",,,Новый КвалификаторыЧисла(10,0)));
	парс.Колонки.Добавить("Значение",Новый ОписаниеТипов("Строка"));
	
	СтрокаOCTET_STRING = Неопределено; //в октетстринг лежит RSAPrivateKey по RFC 3447
	ПарсХекс(парс,ХексСтрокаКлюча, СтрокаOCTET_STRING);
	ЗначениеВРеквизитФормы(парс, "ПарсКлюч");
	
	RSAPrivateKey_SEQUENCE = СтрокаOCTET_STRING.Строки[0];
	// единственный элемент внутри OCTET_STRING, является RSAPrivateKey ::= SEQUENCE {...
	PKey_SEQUENCE_fields = RSAPrivateKey_SEQUENCE.Строки;
	
	//PKey_SEQUENCE_fields[0] - version не нужна
	СтруктураСертификата.Вставить("Modulus",	PKey_SEQUENCE_fields[1].Значение);
	СтруктураСертификата.Вставить("Exponent",	PKey_SEQUENCE_fields[2].Значение);
	СтруктураСертификата.Вставить("D",			PKey_SEQUENCE_fields[3].Значение);
	СтруктураСертификата.Вставить("P",			PKey_SEQUENCE_fields[4].Значение);
	СтруктураСертификата.Вставить("Q",			PKey_SEQUENCE_fields[5].Значение);
	СтруктураСертификата.Вставить("DP",			PKey_SEQUENCE_fields[6].Значение);
	СтруктураСертификата.Вставить("DQ",			PKey_SEQUENCE_fields[7].Значение);
	СтруктураСертификата.Вставить("InverseQ",	PKey_SEQUENCE_fields[8].Значение);
	
	Возврат СтруктураСертификата;
	
	//RFC 3447
   // A.1.2 RSA private key syntax

   //An RSA private key should be represented with the ASN.1 type
   //RSAPrivateKey:

   //   RSAPrivateKey ::= SEQUENCE {
   //  0     version           Version,
   //  1     modulus           INTEGER,  -- n
   //  2     publicExponent    INTEGER,  -- e
   //  3     privateExponent   INTEGER,  -- d
   //  4     prime1            INTEGER,  -- p
   //  5     prime2            INTEGER,  -- q
   //  6     exponent1         INTEGER,  -- d mod (p-1)
   //  7     exponent2         INTEGER,  -- d mod (q-1)
   //  8     coefficient       INTEGER,  -- (inverse of q) mod p
   //  9     otherPrimeInfos   OtherPrimeInfos OPTIONAL
   //   }

   //The fields of type RSAPrivateKey have the following meanings:

   // * version is the version number, for compatibility with future
   //   revisions of this document.  It shall be 0 for this version of the
   //   document, unless multi-prime is used, in which case it shall be 1.

   //         Version ::= INTEGER { two-prime(0), multi(1) }
   //            (CONSTRAINED BY
   //            {-- version must be multi if otherPrimeInfos present --})

   // * modulus is the RSA modulus n.

   // * publicExponent is the RSA public exponent e.

   // * privateExponent is the RSA private exponent d.

   // * prime1 is the prime factor p of n.

   // * prime2 is the prime factor q of n.

   // * exponent1 is d mod (p - 1).

   // * exponent2 is d mod (q - 1).

   // * coefficient is the CRT coefficient q^(-1) mod p.

   // * otherPrimeInfos contains the information for the additional primes
   //   r_3, ..., r_u, in order.  It shall be omitted if version is 0 and
   //   shall contain at least one instance of OtherPrimeInfo if version
   //   is 1.
	
КонецФункции

&НаСервере
Процедура ПарсХекс(Родитель, ХексСтрокаКлюча, СтрокаOCTET_STRING)
	Тэги = Новый Соответствие;
	Тэги.Вставить("30","SEQUENCE");
	Тэги.Вставить("02","INTEGER");
	Тэги.Вставить("06","OBJECT IDENTIFIER");
	Тэги.Вставить("04","OCTET STRING");
	Тэги.Вставить("05","NULL");
	
	Позиция = 1;
	//Родитель = парс;
	Пока Позиция < СтрДлина(ХексСтрокаКлюча) Цикл
		сПарс = Родитель.Строки.Добавить();
		
		сПарс.Класс = Сред(ХексСтрокаКлюча, Позиция, 2);
		Позиция = Позиция + 2;
		сПарс.ИмяКласса = Тэги.Получить(сПарс.Класс);
		
		байт = Сред(ХексСтрокаКлюча, Позиция, 2);
		Если байт = "81" или байт = "82" Тогда
			сПарс.ПредбайтДлины = байт;
			Позиция = Позиция + 2;
			
			КолвоБайтАдресации = Число(байт) - 80;
			сПарс.БайтДлины = Сред(ХексСтрокаКлюча, Позиция, 2 * КолвоБайтАдресации);
			Позиция = Позиция + 2 * КолвоБайтАдресации;
			сПарс.ДлинаЧисло = ЧислоИзШестнадцатеричнойСтроки("0x"+сПарс.БайтДлины);
			
			сПарс.Значение = Сред(ХексСтрокаКлюча, Позиция, 2 * сПарс.ДлинаЧисло);
			Позиция = Позиция + 2 * сПарс.ДлинаЧисло;
			//последнюю позицию сдвинем/несдвинем после Если
			
		Иначе
			сПарс.ПредбайтДлины = ""; //отсутствует
			
			сПарс.БайтДлины = Сред(ХексСтрокаКлюча, Позиция, 2);
			Позиция = Позиция + 2;
			сПарс.ДлинаЧисло = ЧислоИзШестнадцатеричнойСтроки("0x"+сПарс.БайтДлины);
			
			сПарс.Значение = Сред(ХексСтрокаКлюча, Позиция, 2 * сПарс.ДлинаЧисло);
			Позиция = Позиция + 2 * сПарс.ДлинаЧисло;

		КонецЕсли;
		
		Если сПарс.ИмяКласса = "OCTET STRING" Тогда
			СтрокаOCTET_STRING = сПарс;
		КонецЕсли;
		
		Если сПарс.ИмяКласса = "SEQUENCE" или сПарс.ИмяКласса = "OCTET STRING" Тогда
			// эти классы содержат подклассы, разбираем подветки рекурсивно
			ПарсХекс(сПарс, сПарс.Значение, СтрокаOCTET_STRING)
		КонецЕсли;
		
		
	КонецЦикла;
	
КонецПроцедуры

&НаСервере
Функция ВозведениеВСтепеньПоМодулю (Основание, Степень, Модуль)
	
	// Двоичное представление степени переведем в массив нулей и единиц в обратном порядке
	МассивЕдиниц = Новый Массив;
	Значение = Степень;
    Пока Значение>0 цикл
        Остат = Значение%2;
		МассивЕдиниц.Добавить(Остат);
        Значение = (Значение-Остат)/2;
	КонецЦикла;
	
	//Основание переведем в массив по хитрому правилу
	МассивИзОснования = Новый Массив;
	Для сч=0 по МассивЕдиниц.ВГраница() Цикл
		Если сч = 0 тогда
			МассивИзОснования.Добавить(Основание);
		Иначе
			МассивИзОснования.Добавить(pow(МассивИзОснования[сч-1],2)%Модуль);
		КонецЕсли;
	КонецЦикла;
	
	//Вычислим произведение степеней
	Произведение = 1;
	Для сч=0 по МассивЕдиниц.ВГраница() Цикл
		Произведение = Произведение * pow(МассивИзОснования[сч],МассивЕдиниц[сч]);
	КонецЦикла;
	
	Возврат Произведение%Модуль;
	
КонецФункции

&НаСервере
Функция ВозведениеВСтепеньПоМодулю0 (Основание, Степень, Модуль) //долго
	//function modular_pow(base, index_n, modulus)
	//c := 1
	//for index_n_prime = 1 to index_n 
	//    c := (c * base) mod modulus
	//return c
	Остаток = 1;
	Для сч = 1 по Степень Цикл
		Остаток = Остаток * Основание - Цел((Остаток * Основание) / Модуль) * Модуль;
	КонецЦикла;
	Возврат Остаток;
КонецФункции

&НаСервере
// возвращает двоичную подпись
Функция ПолучиьПодписьSHA256RSA(ХешДвоичный, ПараметрыСертификатаСтруктура)
		
	ХешХексСтрока = ПолучитьHexСтрокуИзДвоичныхДанных(ХешДвоичный);
	
	// PKCS #1 v2.2: RSA Cryptography Standard, 9.2 EMSA-PKCS1-v1_5
	// перед подписанием хеш дополняется данными
	// EM  = 0x00 || 0x01 ||PS  || 0x00 ||T
	// T SHA-256:  (0x)30 31 30 0d 06 09 60 86 48 01 65 03 04 02 01 05 00 04 20 || H
	ЕМ = "0001" + "FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF"+
	"00" + "3031300D060960864801650304020105000420" + ХешХексСтрока; 
	
	ХешХексСтрока = ЕМ;
  	хешчисло = ЧислоИзШестнадцатеричнойСтроки("0x"+ХешХексСтрока);
	
	СтрукСерт = ПараметрыСертификатаСтруктура;	
	dP 			= ЧислоИзШестнадцатеричнойСтроки("0x"+СтрукСерт.DP);
	p 			= ЧислоИзШестнадцатеричнойСтроки("0x"+СтрукСерт.P);
	dQ	 		= ЧислоИзШестнадцатеричнойСтроки("0x"+СтрукСерт.DQ);
	q 			= ЧислоИзШестнадцатеричнойСтроки("0x"+СтрукСерт.Q);
	qInv 		= ЧислоИзШестнадцатеричнойСтроки("0x"+СтрукСерт.InverseQ);
	Exponent 	= ЧислоИзШестнадцатеричнойСтроки("0x"+СтрукСерт.Exponent); //открытый параметр ключа
	Modulus 	= ЧислоИзШестнадцатеричнойСтроки("0x"+СтрукСерт.Modulus); //открытый параметр ключа
	
	//s1 = pow(хешчисло,DP_Число)% P_Число;//переполнение десятичной арифметики
	
	// ↓ вычисление подписи по ускоренному алгоритму
	s1 = ВозведениеВСтепеньПоМодулю (хешчисло, dP, p);
	s2 = ВозведениеВСтепеньПоМодулю (хешчисло, dQ, q);
	Если s1>s2 Тогда
		h = ((s1-s2)*qInv)%p
	Иначе
		h = ((s1-s2+p)*qInv)%p
	КонецЕсли;
	s = s2 + q*h; //подпись - число
	// ↑
	
	ПроверкаПодписиЧисло = ВозведениеВСтепеньПоМодулю (s, Exponent, Modulus);
	подписьВерна = (ПроверкаПодписиЧисло = хешчисло);
	Сообщить ("Подпись верна:" + подписьВерна); 
	
	Возврат ДвоичныеИзЧисла(s)
	
КонецФункции


#КонецОбласти


#Область Операции_над_числами


Функция Base64Число(Base64Строка) //по аналогии Base64Строка Base64Значение
	ДвоичныеДанные = Base64Значение(Base64Строка);
	ХексСтрока = ПолучитьHexСтрокуИзДвоичныхДанных(ДвоичныеДанные);
	Возврат ЧислоИзШестнадцатеричнойСтроки("0x"+ХексСтрока);
КонецФункции

// Функция переводит число переданное в параметре
// Значение в строку (либо число) в системе счисления X
// X определяется линой шаблона, представление знаков разрядов
// значение шаблона, где сивол шаблона[k] - есть представление
// Например если шаблок "01", то перевод будет осуществлен в двоичную
// систему счисления, если "01234567", то в восьмиричную
// если "0123456789ABCDEF", то в шестнадцатиричную
// если "ЛИ", то в двоичную, где 0 представлен буквой Л, а 1 буквой И
// вариант шаблона:
// "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwzyzАБВГДЕЖЗИЙКЛМНОПРСТУФХЦЧШЩЬЫЪЭЮЯабвгдежзийклмнопрстуфхцчшщьыъэюя!@#$%^&*()_-=+{}[]\|/,.:;'""><"
// представит Значение в сто пятидесятишести ричной системе счисления,
// где соответствующий символ шаблона означает соответствующую цифру разряда
//
&НаСервере
Функция Из_Число_В_XСчисл(Знач Значение, Шаблон) //Из_Число_В_XСчисл(Знач Значение, "0123456789ABCDEF")
    Результат="";
    Основание = СтрДлина(Шаблон);
    Пока Значение>0 цикл
        Остат = Значение%Основание;
        Результат1=Сред(Шаблон,Остат+1,1);
        Значение = (Значение-Остат)/Основание;
        Результат = Результат1 + Результат;
    КонецЦикла;
    Возврат Результат;
КонецФункции

&НаСервере
Функция ДвоичныеИзЧисла(знач мЧисло)
	МассивЧиселБайт = Новый Массив;
	Пока мЧисло>0 Цикл
		ТекущийБайт = мЧисло%256;
		МассивЧиселБайт.Добавить(ТекущийБайт);
		мЧисло = (мЧисло - ТекущийБайт)/256;
	КонецЦикла;
	РазмерБайт = МассивЧиселБайт.Количество();
	Буфер = Новый БуферДвоичныхДанных(РазмерБайт);
	Для сч = 0 по РазмерБайт-1 Цикл
		Буфер.Установить(РазмерБайт-1-сч, МассивЧиселБайт[сч]);
	КонецЦикла;

	Возврат ПолучитьДвоичныеДанныеИзБуфераДвоичныхДанных(Буфер);
	
КонецФункции

&НаСервере
Функция ЧислоИзДвоичных(ДвоичныеДанные)
	Возврат ЧислоИзШестнадцатеричнойСтроки("0x"+ПолучитьHexСтрокуИзДвоичныхДанных(ДвоичныеДанные));
КонецФункции

&НаСервере
Функция SafeИзUTF(strUtf)
	Буфер = ПолучитьБуферДвоичныхДанныхИзСтроки(strUtf);
	Байтов = Буфер.Размер;
	COMSafeArray = Новый COMSafeArray("VT_UI1", Байтов);//однобайтовый без знака
	Для сч = 0 по Байтов-1 Цикл
		COMSafeArray.SetValue(сч, Буфер.Получить(сч));
	КонецЦикла;
	Возврат COMSafeArray;
КонецФункции

&НаСервере
Функция SafeИзДвоичных(ДвоичныеДанные)
	Буфер = ПолучитьБуферДвоичныхДанныхИзДвоичныхДанных(ДвоичныеДанные);
	Байтов = Буфер.Размер;
	COMSafeArray = Новый COMSafeArray("VT_UI1", Байтов);//однобайтовый без знака
	Для сч = 0 по Байтов-1 Цикл
		COMSafeArray.SetValue(сч, Буфер.Получить(сч));
	КонецЦикла;
	Возврат COMSafeArray;
КонецФункции

&НаСервере
Функция ДвоичныеИзSafe(SafeArrayBin) 
	Буфер = Новый БуферДвоичныхДанных(SafeArrayBin.GetLength());
	Для сч = 0 по SafeArrayBin.GetUpperBound() Цикл
		Буфер.Установить(сч, SafeArrayBin.GetValue(сч));
	КонецЦикла;
	Возврат ПолучитьДвоичныеДанныеИзБуфераДвоичныхДанных(Буфер);
КонецФункции



#КонецОбласти



	


	

	
	
	

	
