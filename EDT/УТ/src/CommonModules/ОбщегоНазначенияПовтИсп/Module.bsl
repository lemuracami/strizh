// Возвращает признак возможности обращения к разделенным данным из текущего сеанса.
// В случае вызова в неразделенной конфигурации возвращает Истина.
//
// Возвращаемое значение:
// Булево.
//
Функция ДоступноИспользованиеРазделенныхДанных() Экспорт
	
	Возврат Истина;
	
КонецФункции

// Возвращает признак включения условного разделения.
// В случае вызова в неразделенной конфигурации возвращает Ложь.
//
Функция РазделениеВключено() Экспорт
	
	Возврат Ложь;
	
КонецФункции

// Возвращает признак наличия в конфигурации общих реквизитов-разделителей.
//
// Возвращаемое значение:
// Булево.
//
Функция ЭтоРазделеннаяКонфигурация() Экспорт
	
	ЕстьРазделители = Ложь;
	
	Возврат ЕстьРазделители;
	
КонецФункции

Функция ЭтоРазделенныйОбъектМетаданных(Знач ИмяОбъектаМетаданных) Экспорт
	
	возврат Ложь;
	
КонецФункции

// Определяет, сеанс запущен с разделителями или без.
//
// Возвращаемое значение:
// Булево.
//
Функция СеансЗапущенБезРазделителей() Экспорт
	
	Возврат Истина;
	
КонецФункции


// Функция возвращает объект WSОпределения созданный с переданными параметрами.
//
// Параметры соответствуют конструктору объекта.
//
//
// Примечание: при получении определения используется кэш, обновление которого осуществляется
//  при смене версии конфигурации. Если для целей отладки требуется обновить
//  значения в кэше, раньше этого времени, следует удалить из регистра сведений 
//  КэшПрограммныхИнтерфейсов соответствующие записи.
//
Функция ПолучитьWSОпределения(Знач АдресWSDL, Знач ИмяПользователя, Знач Пароль) Экспорт
	
	ДоступноПолучениеФайловИзИнтернета = Неопределено;
	СтандартныеПодсистемыПереопределяемый.ДоступноПолучениеФайловИзИнтернета(ДоступноПолучениеФайловИзИнтернета);
	Если ДоступноПолучениеФайловИзИнтернета = Истина Тогда
	
		ПараметрыПолучения = Новый Массив;
		ПараметрыПолучения.Добавить(АдресWSDL);
		ПараметрыПолучения.Добавить(ИмяПользователя);
		ПараметрыПолучения.Добавить(Пароль);
		
		ДанныеWSDL = ОбщегоНазначенияПовтИсп.ПолучитьДанныеКэшаВерсий(
			АдресWSDL, 
			Перечисления.ТипыДанныхКэшаПрограммныхИнтерфейсов.ОписаниеWebСервиса, 
			ОбщегоНазначения.ЗначениеВСтрокуXML(ПараметрыПолучения),
			Ложь);
			
		ИмяФайлаWSDL = ПолучитьИмяВременногоФайла("wsdl");
		
		ДанныеWSDL.Записать(ИмяФайлаWSDL);
		
		Определения = Новый WSОпределения(ИмяФайлаWSDL);
		
		Попытка
			УдалитьФайлы(ИмяФайлаWSDL);
		Исключение
			ЗаписьЖурналаРегистрации("УдалениеВременныхФайлов", УровеньЖурналаРегистрации.Ошибка, , , 
				ПодробноеПредставлениеОшибки(ИнформацияОбОшибке()));
		КонецПопытки;
		
		Возврат Определения;
		
	Иначе
		
		Возврат Новый WSОпределения(АдресWSDL, ИмяПользователя, Пароль);
		
	КонецЕсли;
	
КонецФункции

// Функция возвращает объект WSПрокси созданный с переданными параметрами.
//
// Параметры соответствуют конструктору объекта. См. синтакс-помощник.
//
Функция ПолучитьWSПрокси(Знач АдресWSDL, Знач URIПространстваИмен, Знач ИмяСервиса,
	Знач ИмяТочкиПодключения = "", Знач ИмяПользователя, Знач Пароль) Экспорт
	
	WSОпределения = ОбщегоНазначенияПовтИсп.ПолучитьWSОпределения(АдресWSDL, ИмяПользователя, Пароль);
	
	Если ПустаяСтрока(ИмяТочкиПодключения) Тогда
		ИмяТочкиПодключения = ИмяСервиса + "Soap";
	КонецЕсли;
	
	Прокси = Новый WSПрокси(WSОпределения, URIПространстваИмен, ИмяСервиса, ИмяТочкиПодключения);
	Прокси.Пользователь = ИмяПользователя;
	Прокси.Пароль = Пароль;
	
	Возврат Прокси;
	
КонецФункции

// Функция получает данные кеша версий из ресурса типа ХранилищеЗначения регистра КэшПрограммныхИнтерфейсов.
//
// Параметры:
// Идентификатор - Строка - идентификатор записи кэша
// ТипДанных - ПеречислениеСсылка.ТипыДанныхКэшаПрограммныхИнтерфейсов.
// ПараметрыПолучения - Строка - массив параметров сериализованный в XML для передачи в метод
//  обновления кэша
// ВозвращатьУстаревшиеДанные - Булево - флаг определяющий необходимость ожидания обновления
//  данных в кэше перед возвратом значения, в случае обнаружения факта их устаревания.
//  Истина - всегда использовать данные из кэша, если они там есть. Ложь - ожидать
//  обновления данных кэша, в случае обнаружения факта устаревания данных.
//
// Возвращаемое значение:
// Произвольный.
//
Функция ПолучитьДанныеКэшаВерсий(Знач Идентификатор, Знач ТипДанных, 
		Знач ПараметрыПолучения, Знач ИспользоватьУстаревшиеДанные = Истина) Экспорт
	
	ПараметрыПолучения = ОбщегоНазначения.ЗначениеИзСтрокиXML(ПараметрыПолучения);
	
	УстановитьПривилегированныйРежим(Истина);
	
	Если ОбщегоНазначенияПовтИсп.РазделениеВключено()
		И ОбщегоНазначенияПовтИсп.СеансЗапущенБезРазделителей()
		И ОбщегоНазначения.ИспользованиеРазделителяСеанса() Тогда
		
		ВосстановитьРазделение = Истина;
		
		ОбщегоНазначения.УстановитьРазделениеСеанса(Ложь);
		
	Иначе
		
		ВосстановитьРазделение = Ложь;
		
	КонецЕсли;
	
	Попытка
	
		Запрос = Новый Запрос;
		Запрос.Текст =
		"ВЫБРАТЬ
		|	КэшПрограммныхИнтерфейсов.ДатаОбновления КАК ДатаОбновления,
		|	КэшПрограммныхИнтерфейсов.Данные КАК Данные,
		|	КэшПрограммныхИнтерфейсов.ТипДанных КАК ТипДанных
		|ИЗ
		|	РегистрСведений.КэшПрограммныхИнтерфейсов КАК КэшПрограммныхИнтерфейсов
		|ГДЕ
		|	КэшПрограммныхИнтерфейсов.Идентификатор = &Идентификатор
		|	И КэшПрограммныхИнтерфейсов.ТипДанных = &ТипДанных";
		Запрос.УстановитьПараметр("Идентификатор", Идентификатор);
		Запрос.УстановитьПараметр("ТипДанных", ТипДанных);
		
		НачатьТранзакцию();
		Попытка
			// Не устанавливаем управляемую блокировку что бы другие сеансы могли изменять значение пока эта транзакция активна
			Результат = Запрос.Выполнить();
			ЗафиксироватьТранзакцию();
		Исключение
			ОтменитьТранзакцию();
			ВызватьИсключение;
		КонецПопытки;
		
		ИмяМетодаЗадания = "ОбщегоНазначения.ОбновитьДанныеКэшаВерсий";
		КлючЗадания = Идентификатор + "|" + XMLСтрока(ТипДанных);
		ПараметрыЗадания = Новый Массив;
		ПараметрыЗадания.Добавить(Идентификатор);
		ПараметрыЗадания.Добавить(ТипДанных);
		ПараметрыЗадания.Добавить(ПараметрыПолучения);
		
		ОтборЗаданий = Новый Структура;
		ОтборЗаданий.Вставить("ИмяМетода", ИмяМетодаЗадания);
		ОтборЗаданий.Вставить("Ключ", КлючЗадания);
		ОтборЗаданий.Вставить("Состояние", СостояниеФоновогоЗадания.Активно);
		
		Выборка = Неопределено;
		
		Если Результат.Пустой() Тогда
			
			Если ОбщегоНазначения.ИнформационнаяБазаФайловая() Тогда
				ОбщегоНазначения.ОбновитьДанныеКэшаВерсий(Идентификатор, ТипДанных, ПараметрыПолучения);
			Иначе
				Задания = ФоновыеЗадания.ПолучитьФоновыеЗадания(ОтборЗаданий);
				Если Задания.Количество() = 0 Тогда
					// Запустим новое
					Задание = ФоновыеЗадания.Выполнить(ИмяМетодаЗадания, ПараметрыЗадания, КлючЗадания);
				Иначе
					Задание = Задания[0];
				КонецЕсли;
				
				Попытка
					// Дождемся завершения
					Задание.ОжидатьЗавершения();
				Исключение
					Задание = ФоновыеЗадания.НайтиПоУникальномуИдентификатору(Задание.УникальныйИдентификатор);
					Если Задание.ИнформацияОбОшибке <> Неопределено Тогда
						ЗаписьЖурналаРегистрации("ОбновлениеКэшаВерсий", УровеньЖурналаРегистрации.Ошибка, , ,
							ПодробноеПредставлениеОшибки(Задание.ИнформацияОбОшибке));
						ВызватьИсключение(КраткоеПредставлениеОшибки(Задание.ИнформацияОбОшибке));
					Иначе
						ЗаписьЖурналаРегистрации("ОбновлениеКэшаВерсий", УровеньЖурналаРегистрации.Ошибка, , ,
							ПодробноеПредставлениеОшибки(ИнформацияОбОшибке()));
						ВызватьИсключение;
					КонецЕсли;
				КонецПопытки;
			КонецЕсли;
			
			НачатьТранзакцию();
			Попытка
				Результат = Запрос.Выполнить();
				ЗафиксироватьТранзакцию();
			Исключение
				ОтменитьТранзакцию();
				ВызватьИсключение;
			КонецПопытки;
			
			Если Результат.Пустой() Тогда
				ШаблонСообщения = НСтр("ru = 'Ошибка при обновлении данных кэша версий. 
					|Идентификатор записи: %1
					|ТипДанных информации: %2'");
				ТекстСообщения = СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
					ШаблонСообщения, Идентификатор, ТипДанных);
					
				ВызватьИсключение(ТекстСообщения);
			КонецЕсли;
		Иначе
			
			Выборка = Результат.Выбрать();
			Выборка.Следующий();
			Если ОбщегоНазначения.ЗаписьКэшаВерсийУстарела(Выборка) Тогда
				Если ОбщегоНазначения.ИнформационнаяБазаФайловая() Тогда
					ОбщегоНазначения.ОбновитьДанныеКэшаВерсий(Идентификатор, ТипДанных, ПараметрыПолучения);
					Выборка = Неопределено;
				Иначе
					// Данные устарели
					Задания = ФоновыеЗадания.ПолучитьФоновыеЗадания(ОтборЗаданий);
					Если Задания.Количество() = 0 Тогда
						// Запустим новое
						Задание = ФоновыеЗадания.Выполнить(ИмяМетодаЗадания, ПараметрыЗадания, КлючЗадания);
					Иначе
						Задание = Задания[0];
					КонецЕсли;
					
					Если НЕ ИспользоватьУстаревшиеДанные Тогда
						Попытка
							// Дождемся завершения
							Задание.ОжидатьЗавершения();
						Исключение
							Задание = ФоновыеЗадания.НайтиПоУникальномуИдентификатору(Задание.УникальныйИдентификатор);
							Если Задание.ИнформацияОбОшибке <> Неопределено Тогда
								ЗаписьЖурналаРегистрации("ОбновлениеКэшаВерсий", УровеньЖурналаРегистрации.Ошибка, , ,
									ПодробноеПредставлениеОшибки(Задание.ИнформацияОбОшибке));
								ВызватьИсключение(КраткоеПредставлениеОшибки(Задание.ИнформацияОбОшибке));
							Иначе
								ЗаписьЖурналаРегистрации("ОбновлениеКэшаВерсий", УровеньЖурналаРегистрации.Ошибка, , ,
									ПодробноеПредставлениеОшибки(ИнформацияОбОшибке()));
								ВызватьИсключение;
							КонецЕсли;
						КонецПопытки;
					КонецЕсли;
				КонецЕсли;
			КонецЕсли;
			
		КонецЕсли;
		
		Если Выборка = Неопределено Тогда
			Выборка = Результат.Выбрать();
			Выборка.Следующий();
		КонецЕсли;
		
	Исключение
		Если ВосстановитьРазделение Тогда
			ОбщегоНазначения.УстановитьРазделениеСеанса(Истина);
		КонецЕсли;
		ВызватьИсключение;
	КонецПопытки;
	
	Если ВосстановитьРазделение Тогда
		ОбщегоНазначения.УстановитьРазделениеСеанса(Истина);
	КонецЕсли;
	
	Возврат Выборка.Данные.Получить();
	
КонецФункции

// Функция возвращает имя каталога временных файлов.
//
// Возвращаемое значение:
//	Строка - путь к каталогу временных файлов.
//
Функция КаталогВременногоХранилищаФайлов() Экспорт
	
	// Если файловая база, то возвращается КаталогВременныхФайлов.
	Если ОбщегоНазначения.ИнформационнаяБазаФайловая() Тогда 
		Возврат СокрЛП(КаталогВременныхФайлов());
	КонецЕсли;
	
	ОбщийТипПлатформы = "Windows";
	
	СистемнаяИнформация = Новый СистемнаяИнформация;
	
	Если    СистемнаяИнформация.ТипПлатформы = ТипПлатформы.Windows_x86
		ИЛИ СистемнаяИнформация.ТипПлатформы = ТипПлатформы.Windows_x86_64 Тогда
		
		Результат         = Константы.КаталогВременныхФайловДляWindows.Получить();
		
	ИначеЕсли СистемнаяИнформация.ТипПлатформы = ТипПлатформы.Linux_x86
		ИЛИ   СистемнаяИнформация.ТипПлатформы = ТипПлатформы.Linux_x86_64 Тогда
		
		Результат         = Константы.КаталогВременныхФайловДляLinux.Получить();
		ОбщийТипПлатформы = "Linux";
		
	Иначе
		
		Результат         = Константы.КаталогВременныхФайловДляWindows.Получить();
		
	КонецЕсли;
	
	ЗначениеПараметра = ?(ОбщийТипПлатформы = "Linux", "Каталог временных файлов для Linux", "Каталог временных файлов для Windows");
	
	Если ПустаяСтрока(Результат) Тогда
		
		Результат = СокрЛП(КаталогВременныхФайлов());
		
	Иначе
		
		Результат = СокрЛП(Результат);
		
		// Проверка существования каталога
		Каталог = Новый Файл(Результат);
		
		Если Не Каталог.Существует() Тогда
			
			ШаблонСообщения = НСтр("ru = 'Каталог временных файлов не существует.
					|Необходимо убедиться, что в форме настройки программы задано правильное значение константы
					|""%1"".'");
			ШаблонСообщения = СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(ШаблонСообщения, ЗначениеПараметра);
			ВызватьИсключение ШаблонСообщения;
			
		КонецЕсли;
		
	КонецЕсли;
	
	Возврат Результат;
	
КонецФункции

// Функция возвращает объект WSПрокси созданный с переданными параметрами.
//
// Параметры соответствуют конструктору объекта. См. синтакс-помощник.
//
Функция WSПрокси(Знач АдресWSDL, Знач URIПространстваИмен, Знач ИмяСервиса,
	Знач ИмяТочкиПодключения = "", Знач ИмяПользователя, Знач Пароль, Знач Таймаут = Неопределено) Экспорт
	
	Возврат ОбщегоНазначения.ВнутренняяWSПрокси(АдресWSDL, URIПространстваИмен, ИмяСервиса, 
		ИмяТочкиПодключения, ИмяПользователя, Пароль, Таймаут);
	
КонецФункции

// Функция возвращает объект WSОпределения созданный с переданными параметрами.
//
// Параметры
//  АдресWSDL - Строка - местораположение wsdl
//  ИмяПользователя - Строка - имя пользователя для входа на сервер
//  Пароль - Строка - пароль пользователя
//
// Примечание: при получении определения используется кэш, обновление которого осуществляется
//  при смене версии конфигурации. Если для целей отладки требуется обновить
//  значения в кэше, раньше этого времени, следует удалить из регистра сведений 
//  КэшПрограммныхИнтерфейсов соответствующие записи.
//
Функция WSОпределения(Знач АдресWSDL, Знач ИмяПользователя, Знач Пароль) Экспорт
	
	Возврат ОбщегоНазначения.WSОпределения(АдресWSDL, ИмяПользователя, Пароль);
	
КонецФункции

//+Степанов
Функция ИспользуемаяСистемаРаспознаванияАдресов(РучнойПоиск = Ложь) Экспорт
	Если РучнойПоиск Тогда 
		СистемаРаспознавания = РегистрыСведений.НастройкиУчетаОбщие.ПолучитьПоследнее().СистемаРаспознаванияАдресовПриРучнойПривязке;
	Иначе	
		СистемаРаспознавания = РегистрыСведений.НастройкиУчетаОбщие.ПолучитьПоследнее().СистемаРаспознаванияАдресов;
	КонецЕсли;	
	
	Если ЗначениеЗаполнено(СистемаРаспознавания) Тогда 
		Возврат СистемаРаспознавания;	
	Иначе
		Возврат Перечисления.СистемыРаспознаванияАдресов.Yandex;
	КонецЕсли;	
КонецФункции	