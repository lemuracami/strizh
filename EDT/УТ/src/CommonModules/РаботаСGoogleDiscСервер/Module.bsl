
#Область НеИспользуется

// Функция - Обновление токена
//
// Параметры:
//  ClientId	 - 	 Строка 
//  ClientSecret - 	 Строка 
//  RefreshToken - 	 Строка 
// 
// Возвращаемое значение:
//   Структура. Ключи структуры: access_token,expires_in,access_lifetime,ОписаниеОшибки 
//
Функция ОбновлениеТокена(ClientId, ClientSecret, RefreshToken)
	
	СтруктураВозврата = Новый Структура("access_token,expires_in,access_lifetime,ОписаниеОшибки",
	Неопределено, Неопределено, Неопределено, Неопределено);
	
	ПараметрыЗапроса = "";
	ПараметрыЗапроса = ПараметрыЗапроса + "client_id=" + ClientId;
	ПараметрыЗапроса = ПараметрыЗапроса + "&client_secret=" + ClientSecret;
	ПараметрыЗапроса = ПараметрыЗапроса + "&refresh_token=" + RefreshToken;
	ПараметрыЗапроса = ПараметрыЗапроса + "&grant_type=refresh_token";
	
	ЗащищенноеСоединение = Новый ЗащищенноеСоединениеOpenSSL(Неопределено, Неопределено);
	Соединение = Новый HTTPСоединение("www.googleapis.com", , , , , ,ЗащищенноеСоединение);
	
	Заголовки = Новый Соответствие;
	Заголовки.Вставить("Content-Type", "application/x-www-form-urlencoded");
	Заголовки.Вставить("Content-Charset", "utf-8");		
	
	ОписаниеОшибки = "";
	
	HTTPЗапрос = Новый HTTPЗапрос("/oauth2/v4/token", Заголовки);		
	HTTPЗапрос.УстановитьТелоИзСтроки(ПараметрыЗапроса, КодировкаТекста.UTF8);
	Результат  = Соединение.ОтправитьДляОбработки(HTTPЗапрос);
	
	Если Результат.КодСостояния <> 200 И Результат.КодСостояния <> 204 тогда
		СтрокаОтвет = Результат.ПолучитьТелоКакСтроку();
		ВызватьИсключение СтрокаОтвет;
	КонецЕсли;
	
	ТекущаяДата = ТекущаяДата();
	СтрокаОтвет = Результат.ПолучитьТелоКакСтроку();
	
	Чтение = Новый ЧтениеJSON;
	Чтение.УстановитьСтроку(СтрокаОтвет);
	ДанныеОтвет = ПрочитатьJSON(Чтение, Ложь);
	Чтение.Закрыть();
	
	Если Не ДанныеОтвет = Неопределено Тогда
		Если ДанныеОтвет.Свойство("error") Тогда
			ОписаниеОшибки = СтрШаблон(
			"error=%1: %2",
			ДанныеОтвет.error,
			ДанныеОтвет.error_description
			);
		Иначе	
			СтруктураВозврата.access_token = ДанныеОтвет.access_token;
			СтруктураВозврата.expires_in = ДанныеОтвет.expires_in;
			СтруктураВозврата.access_lifetime = ТекущаяДата + Число(ДанныеОтвет.expires_in);
		КонецЕсли;
	Иначе
		СтруктураВозврата.ОписаниеОшибки = НСтр("ru='Не получены данные от сервера!'");		
	КонецЕсли;		
	
	Возврат СтруктураВозврата;
	
КонецФункции

// Функция - Авторизация
//
// Параметры:
//  AuthorizationCode	 - 	 Строка 
//  ClientId			 - 	 Строка 
//  ClientSecret		 - 	 Строка 
// 
// Возвращаемое значение:
//   Структура. Ключи структуры: access_token,expires_in,access_lifetime,refresh_token,ОписаниеОшибки  
//
функция Авторизация(AuthorizationCode, ClientId, ClientSecret)
	
	СтруктураВозврата = Новый Структура("access_token,expires_in,access_lifetime,refresh_token,ОписаниеОшибки",
	Неопределено,Неопределено,Неопределено,Неопределено,Неопределено);
	
	ПараметрыЗапроса = "";
	ПараметрыЗапроса = ПараметрыЗапроса + "code=" + AuthorizationCode;
	ПараметрыЗапроса = ПараметрыЗапроса + "&client_id=" + ClientId;
	ПараметрыЗапроса = ПараметрыЗапроса + "&client_secret=" + ClientSecret;
	ПараметрыЗапроса = ПараметрыЗапроса + "&redirect_uri=urn:ietf:wg:oauth:2.0:oob";
	ПараметрыЗапроса = ПараметрыЗапроса + "&grant_type=authorization_code";
	
	ЗащищенноеСоединение = Новый ЗащищенноеСоединениеOpenSSL(Неопределено, Неопределено);
	
	Соединение = Новый HTTPСоединение("www.googleapis.com", , , , , ,ЗащищенноеСоединение);
	
	Заголовки = Новый Соответствие;
	Заголовки.Вставить("Content-Type", "application/x-www-form-urlencoded");
	Заголовки.Вставить("Content-Charset", "utf-8");		
	
	ОписаниеОшибки = "";
	
	HTTPЗапрос = Новый HTTPЗапрос("/oauth2/v4/token", Заголовки);		
	HTTPЗапрос.УстановитьТелоИзСтроки(ПараметрыЗапроса, КодировкаТекста.UTF8);
	
	Результат  = Соединение.ОтправитьДляОбработки(HTTPЗапрос);
	
	Если Результат.КодСостояния <> 200 И Результат.КодСостояния <> 204 тогда
		СтрокаОтвет = Результат.ПолучитьТелоКакСтроку();
		ВызватьИсключение СтрокаОтвет;
	КонецЕсли;
	
	ТекущаяДата = ТекущаяДата();
	
	СтрокаОтвет = Результат.ПолучитьТелоКакСтроку();
	
	Чтение = Новый ЧтениеJSON;
	Чтение.УстановитьСтроку(СтрокаОтвет);
	ДанныеОтвет = ПрочитатьJSON(Чтение, Истина);
	Чтение.Закрыть();
	
	Если Не ДанныеОтвет = Неопределено Тогда
		Если НЕ ДанныеОтвет.Получить("error") = Неопределено Тогда
			ОписаниеОшибки = СтрШаблон(
			"error=%1: %2",
			ДанныеОтвет.Получить("error"),
			ДанныеОтвет.Получить("error_description")
			);
		Иначе
			СтруктураВозврата.access_token = ДанныеОтвет.Получить("access_token");
			СтруктураВозврата.expires_in = ДанныеОтвет.Получить("expires_in");
			СтруктураВозврата.access_lifetime = ТекущаяДата + Число(СтруктураВозврата.expires_in);
			СтруктураВозврата.refresh_token = ДанныеОтвет.Получить("refresh_token"); 
		КонецЕсли;
	Иначе
		СтруктураВозврата.ОписаниеОшибки = НСтр("ru='Не получены данные от сервера!'");		
	КонецЕсли;
	
	Возврат СтруктураВозврата;
	
КонецФункции

// Процедура - Обновить существующий файл на гугл диске
//
// Параметры:
//  ПутьКФайлу	 - 	 путь к файлу (данные файла, который необходимо обновить
//	fileId 		 - id файла на гугл диске, который необходимо обновить
//  access_token - 	 токен 
//  mimeType	 - 	 "XLSX", "application/vnd.ms-excel
//	"XLS", "application/vnd.ms-excel"
//	"XLS95", "application/vnd.ms-excel"
//	"XLS97", "application/vnd.ms-excel"
//	"DOCX", "application/msword"
//	"HTML", "text/html"
//	"HTML3", "text/html"
//	"HTML4", "text/html"
//	"HTML5", "text/html"
//	"ODS", "application/vnd.oasis.opendocument.spreadsheet"
//	"PDF", "application/pdf" 
//Другие типы можно посмотреть в документации к апи
//
Процедура ОбновитьСуществующийФайлНаГуглДиске(ПутьКФайлу, access_token, mimeType, fileId) Экспорт
		
	Файл = Новый Файл(ПутьКФайлу);
	boundary = СтрЗаменить(Строка(Новый УникальныйИдентификатор()), "-", "");
			
	//Метаданные файла {{
	Свойства = Новый Соответствие();
	Свойства.Вставить("name", Файл.Имя);
	Свойства.Вставить("mimeType", mimeType); // тип файла
	
	ЗаписьJSON = Новый ЗаписьJSON;
	ЗаписьJSON.УстановитьСтроку();
	ЗаписатьJSON(ЗаписьJSON, Свойства);
	СтрокаМетаданныеФайла = ЗаписьJSON.Закрыть();
	
	Поток = Новый ПотокВПамяти();
	ЗаписьДанных = Новый ЗаписьДанных(Поток);
	
	ЗаписьДанных.ЗаписатьСтроку("Content-Type: application/json; charset=UTF-8");
	ЗаписьДанных.ЗаписатьСтроку("");
	ЗаписьДанных.ЗаписатьСтроку(СтрокаМетаданныеФайла);
	
	ЗаписьДанных.Закрыть();
	
	ДвоичныеДанныеМетаданные = Поток.ЗакрытьИПолучитьДвоичныеДанные();
	//Метаданные файла }}
	
	//Данные файла {{
	ДвоичныеДанные = Новый ДвоичныеДанные(ПутьКФайлу); // двоичные данные файла
	Поток = Новый ПотокВПамяти();
	ЗаписьДанных = Новый ЗаписьДанных(Поток);
	
	ЗаписьДанных.ЗаписатьСтроку("Content-Type: " + mimeType);
	ЗаписьДанных.ЗаписатьСтроку("");
	ЗаписьДанных.Записать(ДвоичныеДанные);
	
	ЗаписьДанных.Закрыть();
	
	ДвоичныеДанныеФайла = Поток.ЗакрытьИПолучитьДвоичныеДанные();
	//Данные файла }}
	
	//Формирование тела запроса {{
	ПотокТело = Новый ПотокВПамяти();
	ЗаписьДанных = Новый ЗаписьДанных(ПотокТело);
	ЗаписьДанных.ЗаписатьСтроку("--" + boundary);
	ЗаписьДанных.Записать(ДвоичныеДанныеМетаданные);
	ЗаписьДанных.ЗаписатьСтроку("--" + boundary);
	ЗаписьДанных.Записать(ДвоичныеДанныеФайла);
	ЗаписьДанных.ЗаписатьСтроку("--" + boundary + "--");
	ЗаписьДанных.ЗаписатьСтроку("--" + boundary + "--");
	
	ЗаписьДанных.Закрыть();
	
	ДвоичныеДанныеТело = ПотокТело.ЗакрытьИПолучитьДвоичныеДанные();
	//формирование тела запроса }}
	
	Заголовки  = Новый Соответствие;
	Заголовки.Вставить("Authorization", "Bearer " + access_token);
	Заголовки.Вставить("Content-Type", 	"Multipart/Related; boundary=" + boundary);
	Заголовки.Вставить("Content-Length", Формат(ДвоичныеДанныеТело.Размер(), "ЧГ="));
	
	HTTPЗапрос = Новый HTTPЗапрос("/upload/drive/v3/files/" + fileId + "?uploadType=multipart", Заголовки);
	HTTPЗапрос.УстановитьТелоИзДвоичныхДанных(ДвоичныеДанныеТело);
	
	SSL = Новый ЗащищенноеСоединениеOpenSSL(Неопределено, Неопределено);
	Соединение = Новый HTTPСоединение("www.googleapis.com",,,,,,SSL);
	
	Результат = Соединение.Изменить(HTTPЗапрос);//patch запрос
	
	Если Результат.КодСостояния <> 200 И Результат.КодСостояния <> 204 тогда
		СтрокаОтвет = Результат.ПолучитьТелоКакСтроку();
		ВызватьИсключение СтрокаОтвет;
	КонецЕсли;
	
КонецПроцедуры

// Процедура - Обновить существующий файл на гугл диске
//
// Параметры:
//  ПутьКФайлу	 - 	 путь к файлу (данные файла, который необходимо обновить
//	fileId 		 - id файла на гугл диске, который необходимо обновить
//  access_token - 	 токен 
//  mimeType	 - 	 "XLSX", "application/vnd.ms-excel
//	"XLS", "application/vnd.ms-excel"
//	"XLS95", "application/vnd.ms-excel"
//	"XLS97", "application/vnd.ms-excel"
//	"DOCX", "application/msword"
//	"HTML", "text/html"
//	"HTML3", "text/html"
//	"HTML4", "text/html"
//	"HTML5", "text/html"
//	"ODS", "application/vnd.oasis.opendocument.spreadsheet"
//	"PDF", "application/pdf" 
//Другие типы можно посмотреть в документации к апи
//
Процедура ЗагрузитьФайлНаГуглДиск(ПутьКФайлу, access_token, mimeType) Экспорт
	
	Файл = Новый Файл(ПутьКФайлу);
	boundary = СтрЗаменить(Строка(Новый УникальныйИдентификатор()), "-", "");
		
	//Метаданные файла {{
	Свойства = Новый Соответствие();
	Свойства.Вставить("name", Файл.Имя);
	Свойства.Вставить("mimeType", mimeType); // тип файла
	
	ЗаписьJSON = Новый ЗаписьJSON;
	ЗаписьJSON.УстановитьСтроку();
	ЗаписатьJSON(ЗаписьJSON, Свойства);
	СтрокаМетаданныеФайла = ЗаписьJSON.Закрыть();
	
	Поток = Новый ПотокВПамяти();
	ЗаписьДанных = Новый ЗаписьДанных(Поток);
	
	ЗаписьДанных.ЗаписатьСтроку("Content-Type: application/json; charset=UTF-8");
	ЗаписьДанных.ЗаписатьСтроку("");
	ЗаписьДанных.ЗаписатьСтроку(СтрокаМетаданныеФайла);
	
	ЗаписьДанных.Закрыть();
	
	ДвоичныеДанныеМетаданные = Поток.ЗакрытьИПолучитьДвоичныеДанные();
	//Метаданные файла }}
	
	//Данные файла {{
	
	ДвоичныеДанные = Новый ДвоичныеДанные(ПутьКФайлу); // двоичные данные файла
		
	Поток = Новый ПотокВПамяти();
	ЗаписьДанных = Новый ЗаписьДанных(Поток);
	
	ЗаписьДанных.ЗаписатьСтроку("Content-Type: " + mimeType);
	ЗаписьДанных.ЗаписатьСтроку("");
	ЗаписьДанных.Записать(ДвоичныеДанные);
	
	ЗаписьДанных.Закрыть();
	
	ДвоичныеДанныеФайла = Поток.ЗакрытьИПолучитьДвоичныеДанные();
	//Данные файла }}
	
	//формирование тела запроса {{
	ПотокТело = Новый ПотокВПамяти();
	ЗаписьДанных = Новый ЗаписьДанных(ПотокТело);
	ЗаписьДанных.ЗаписатьСтроку("--" + boundary);
	ЗаписьДанных.Записать(ДвоичныеДанныеМетаданные);
	ЗаписьДанных.ЗаписатьСтроку("--" + boundary);
	ЗаписьДанных.Записать(ДвоичныеДанныеФайла);
	ЗаписьДанных.ЗаписатьСтроку("--" + boundary + "--");
	ЗаписьДанных.ЗаписатьСтроку("--" + boundary + "--");
	
	ЗаписьДанных.Закрыть();
	
	ДвоичныеДанныеТело = ПотокТело.ЗакрытьИПолучитьДвоичныеДанные();
	//формирование тела запроса }}
	
	Заголовки  = Новый Соответствие;
	Заголовки.Вставить("Authorization", "Bearer " + access_token);
	Заголовки.Вставить("Content-Type", 	"Multipart/Related; boundary=" + boundary);
	Заголовки.Вставить("Content-Length", Формат(ДвоичныеДанныеТело.Размер(), "ЧГ="));
	
	HTTPЗапрос = Новый HTTPЗапрос("/upload/drive/v3/files?uploadType=multipart", Заголовки);
	HTTPЗапрос.УстановитьТелоИзДвоичныхДанных(ДвоичныеДанныеТело);
	
	SSL = Новый ЗащищенноеСоединениеOpenSSL(Неопределено, Неопределено);
	Соединение = Новый HTTPСоединение("www.googleapis.com",,,,,,SSL);
	
	Результат = Соединение.ОтправитьДляОбработки(HTTPЗапрос);// post запрос
	
	Если Результат.КодСостояния <> 200 И Результат.КодСостояния <> 204 тогда
		СтрокаОтвет = Результат.ПолучитьТелоКакСтроку();
		ВызватьИсключение СтрокаОтвет;
	КонецЕсли;
	
КонецПроцедуры

#КонецОбласти

Процедура ПарсХекс(Родитель, ХексСтрокаКлюча, СтрокаOCTET_STRING)
	Тэги = Новый Соответствие;
	Тэги.Вставить("30","SEQUENCE");
	Тэги.Вставить("02","INTEGER");
	Тэги.Вставить("06","OBJECT IDENTIFIER");
	Тэги.Вставить("04","OCTET STRING");
	Тэги.Вставить("05","NULL");
	
	Позиция = 1;
	//Родитель = парс;
	Пока Позиция < СтрДлина(ХексСтрокаКлюча) Цикл
		сПарс = Родитель.Строки.Добавить();
		
		сПарс.Класс = Сред(ХексСтрокаКлюча, Позиция, 2);
		Позиция = Позиция + 2;
		сПарс.ИмяКласса = Тэги.Получить(сПарс.Класс);
		
		байт = Сред(ХексСтрокаКлюча, Позиция, 2);
		Если байт = "81" или байт = "82" Тогда
			сПарс.ПредбайтДлины = байт;
			Позиция = Позиция + 2;
			
			КолвоБайтАдресации = Число(байт) - 80;
			сПарс.БайтДлины = Сред(ХексСтрокаКлюча, Позиция, 2 * КолвоБайтАдресации);
			Позиция = Позиция + 2 * КолвоБайтАдресации;
			сПарс.ДлинаЧисло = ЧислоИзШестнадцатеричнойСтроки("0x"+сПарс.БайтДлины);
			
			сПарс.Значение = Сред(ХексСтрокаКлюча, Позиция, 2 * сПарс.ДлинаЧисло);
			Позиция = Позиция + 2 * сПарс.ДлинаЧисло;
			//последнюю позицию сдвинем/несдвинем после Если
			
		Иначе
			сПарс.ПредбайтДлины = ""; //отсутствует
			
			сПарс.БайтДлины = Сред(ХексСтрокаКлюча, Позиция, 2);
			Позиция = Позиция + 2;
			сПарс.ДлинаЧисло = ЧислоИзШестнадцатеричнойСтроки("0x"+сПарс.БайтДлины);
			
			сПарс.Значение = Сред(ХексСтрокаКлюча, Позиция, 2 * сПарс.ДлинаЧисло);
			Позиция = Позиция + 2 * сПарс.ДлинаЧисло;

		КонецЕсли;
		
		Если сПарс.ИмяКласса = "OCTET STRING" Тогда
			СтрокаOCTET_STRING = сПарс;
		КонецЕсли;
		
		Если сПарс.ИмяКласса = "SEQUENCE" или сПарс.ИмяКласса = "OCTET STRING" Тогда
			// эти классы содержат подклассы, разбираем подветки рекурсивно
			ПарсХекс(сПарс, сПарс.Значение, СтрокаOCTET_STRING)
		КонецЕсли;
		
		
	КонецЦикла;
	
КонецПроцедуры

Функция ПолучитьСтруктуруСертификата()
	
	//МакетПодписиДвоичный = ПолучитьМакет("ПодписьGoogle");
	МакетПодписиДвоичный = Обработки.GoogleSheets.ПолучитьМакет("JSON");
	
	СтруктураСертификата = Новый Структура;
	жсон = Новый ЧтениеJSON;
	жсон.УстановитьСтроку(ПолучитьСтрокуИзДвоичныхДанных(МакетПодписиДвоичный));
	Пока жсон.Прочитать() Цикл
		Если жсон.ТипТекущегоЗначения = ТипЗначенияJSON.ИмяСвойства Тогда
			ИмяСвойства = жсон.ТекущееЗначение;
			жсон.Прочитать();
			ЗначениеСвойства =  жсон.ТекущееЗначение;
			СтруктураСертификата.Вставить(ИмяСвойства, ЗначениеСвойства);
		КонецЕсли;
	КонецЦикла;
	//РасшаритьДляЕмейла = СтруктураСертификата.client_email;
	
	КлючСтрока = СтруктураСертификата.private_key;
	КлючСтрока = СтрЗаменить(КлючСтрока,"-----BEGIN PRIVATE KEY-----","");
	КлючСтрока = СтрЗаменить(КлючСтрока,"-----END PRIVATE KEY-----","");
	ХексСтрокаКлюча = ПолучитьHexСтрокуИзДвоичныхДанных(Base64Значение(КлючСтрока));
	Тэги = Новый Соответствие;
	Тэги.Вставить("30","SEQUENCE");
	Тэги.Вставить("02","INTEGER");
	Тэги.Вставить("06","OBJECT IDENTIFIER");
	Тэги.Вставить("04","OCTET STRING");
	Тэги.Вставить("05","NULL");
	
	ДлинаАдресаОдинБайт = "81";
	ДлинаАдресаДваБайта = "82";
	
	парс = Новый ДеревоЗначений;
	парс.Колонки.Добавить("Класс",Новый ОписаниеТипов("Строка",,,,Новый КвалификаторыСтроки(2)));
	парс.Колонки.Добавить("ИмяКласса",Новый ОписаниеТипов("Строка"));
	парс.Колонки.Добавить("ПредбайтДлины",Новый ОписаниеТипов("Строка",,,,Новый КвалификаторыСтроки(2)));
	парс.Колонки.Добавить("БайтДлины",Новый ОписаниеТипов("Строка",,,,Новый КвалификаторыСтроки(4)));
	парс.Колонки.Добавить("ДлинаЧисло", Новый ОписаниеТипов("Число",,,Новый КвалификаторыЧисла(10,0)));
	парс.Колонки.Добавить("Значение",Новый ОписаниеТипов("Строка"));
	
	СтрокаOCTET_STRING = Неопределено; //в октетстринг лежит RSAPrivateKey по RFC 3447
	ПарсХекс(парс,ХексСтрокаКлюча, СтрокаOCTET_STRING);
	//ЗначениеВРеквизитФормы(парс, "ПарсКлюч");
	
	RSAPrivateKey_SEQUENCE = СтрокаOCTET_STRING.Строки[0];
	// единственный элемент внутри OCTET_STRING, является RSAPrivateKey ::= SEQUENCE {...
	PKey_SEQUENCE_fields = RSAPrivateKey_SEQUENCE.Строки;
	
	//PKey_SEQUENCE_fields[0] - version не нужна
	СтруктураСертификата.Вставить("Modulus",	PKey_SEQUENCE_fields[1].Значение);
	СтруктураСертификата.Вставить("Exponent",	PKey_SEQUENCE_fields[2].Значение);
	СтруктураСертификата.Вставить("D",			PKey_SEQUENCE_fields[3].Значение);
	СтруктураСертификата.Вставить("P",			PKey_SEQUENCE_fields[4].Значение);
	СтруктураСертификата.Вставить("Q",			PKey_SEQUENCE_fields[5].Значение);
	СтруктураСертификата.Вставить("DP",			PKey_SEQUENCE_fields[6].Значение);
	СтруктураСертификата.Вставить("DQ",			PKey_SEQUENCE_fields[7].Значение);
	СтруктураСертификата.Вставить("InverseQ",	PKey_SEQUENCE_fields[8].Значение);
	
	Возврат СтруктураСертификата;
	
	//RFC 3447
   // A.1.2 RSA private key syntax

   //An RSA private key should be represented with the ASN.1 type
   //RSAPrivateKey:

   //   RSAPrivateKey ::= SEQUENCE {
   //  0     version           Version,
   //  1     modulus           INTEGER,  -- n
   //  2     publicExponent    INTEGER,  -- e
   //  3     privateExponent   INTEGER,  -- d
   //  4     prime1            INTEGER,  -- p
   //  5     prime2            INTEGER,  -- q
   //  6     exponent1         INTEGER,  -- d mod (p-1)
   //  7     exponent2         INTEGER,  -- d mod (q-1)
   //  8     coefficient       INTEGER,  -- (inverse of q) mod p
   //  9     otherPrimeInfos   OtherPrimeInfos OPTIONAL
   //   }

   //The fields of type RSAPrivateKey have the following meanings:

   // * version is the version number, for compatibility with future
   //   revisions of this document.  It shall be 0 for this version of the
   //   document, unless multi-prime is used, in which case it shall be 1.

   //         Version ::= INTEGER { two-prime(0), multi(1) }
   //            (CONSTRAINED BY
   //            {-- version must be multi if otherPrimeInfos present --})

   // * modulus is the RSA modulus n.

   // * publicExponent is the RSA public exponent e.

   // * privateExponent is the RSA private exponent d.

   // * prime1 is the prime factor p of n.

   // * prime2 is the prime factor q of n.

   // * exponent1 is d mod (p - 1).

   // * exponent2 is d mod (q - 1).

   // * coefficient is the CRT coefficient q^(-1) mod p.

   // * otherPrimeInfos contains the information for the additional primes
   //   r_3, ..., r_u, in order.  It shall be omitted if version is 0 and
   //   shall contain at least one instance of OtherPrimeInfo if version
   //   is 1.
	
КонецФункции

// существует изменённый Base64 для URL, где не используется заполнение символом = 
// и символы + и / соответственно заменяются на * и -
// -------- подошел второй ↓ вариант плюс убраны заполнения символом "=" ----------
// Base64-кодирования URL адресов признается вариант, 
// когда символы + и / заменяются, соответственно, на - и _ (RFC 3548, раздел 4). 
Функция Base64Url(ДвоичныеДанные)
	
	бейс64строка = Base64Строка(ДвоичныеДанные);
	бейс64строка = стрЗаменить(бейс64строка, "+", "-");
	бейс64строка = стрЗаменить(бейс64строка, "/", "_");
	бейс64строка = стрЗаменить(бейс64строка, Символы.ВК, "");
	бейс64строка = стрЗаменить(бейс64строка, Символы.ПС, "");
	
	Если Прав(бейс64строка, 2) = "==" Тогда
		бейс64строка = Лев(бейс64строка,СтрДлина(бейс64строка)-2);
		
	ИначеЕсли Прав(бейс64строка, 1) = "=" Тогда
		бейс64строка = Лев(бейс64строка,СтрДлина(бейс64строка)-1);
	КонецЕсли;
	
	Возврат бейс64строка;
	
КонецФункции

Функция ВозведениеВСтепеньПоМодулю (Основание, Степень, Модуль)
	
	// Двоичное представление степени переведем в массив нулей и единиц в обратном порядке
	МассивЕдиниц = Новый Массив;
	Значение = Степень;
    Пока Значение>0 цикл
        Остат = Значение%2;
		МассивЕдиниц.Добавить(Остат);
        Значение = (Значение-Остат)/2;
	КонецЦикла;
	
	//Основание переведем в массив по хитрому правилу
	МассивИзОснования = Новый Массив;
	Для сч=0 по МассивЕдиниц.ВГраница() Цикл
		Если сч = 0 тогда
			МассивИзОснования.Добавить(Основание);
		Иначе
			МассивИзОснования.Добавить(pow(МассивИзОснования[сч-1],2)%Модуль);
		КонецЕсли;
	КонецЦикла;
	
	//Вычислим произведение степеней
	Произведение = 1;
	Для сч=0 по МассивЕдиниц.ВГраница() Цикл
		Произведение = Произведение * pow(МассивИзОснования[сч],МассивЕдиниц[сч]);
	КонецЦикла;
	
	Возврат Произведение%Модуль;
	
КонецФункции

Функция ДвоичныеИзЧисла(знач мЧисло)
	МассивЧиселБайт = Новый Массив;
	Пока мЧисло>0 Цикл
		ТекущийБайт = мЧисло%256;
		МассивЧиселБайт.Добавить(ТекущийБайт);
		мЧисло = (мЧисло - ТекущийБайт)/256;
	КонецЦикла;
	РазмерБайт = МассивЧиселБайт.Количество();
	Буфер = Новый БуферДвоичныхДанных(РазмерБайт);
	Для сч = 0 по РазмерБайт-1 Цикл
		Буфер.Установить(РазмерБайт-1-сч, МассивЧиселБайт[сч]);
	КонецЦикла;

	Возврат ПолучитьДвоичныеДанныеИзБуфераДвоичныхДанных(Буфер);
	
КонецФункции

// возвращает двоичную подпись
Функция ПолучитьПодписьSHA256RSA(ХешДвоичный, ПараметрыСертификатаСтруктура)
		
	ХешХексСтрока = ПолучитьHexСтрокуИзДвоичныхДанных(ХешДвоичный);
	
	// PKCS #1 v2.2: RSA Cryptography Standard, 9.2 EMSA-PKCS1-v1_5
	// перед подписанием хеш дополняется данными
	// EM  = 0x00 || 0x01 ||PS  || 0x00 ||T
	// T SHA-256:  (0x)30 31 30 0d 06 09 60 86 48 01 65 03 04 02 01 05 00 04 20 || H
	ЕМ = "0001" + "FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF"+
	"00" + "3031300D060960864801650304020105000420" + ХешХексСтрока; 
	
	ХешХексСтрока = ЕМ;
  	хешчисло = ЧислоИзШестнадцатеричнойСтроки("0x"+ХешХексСтрока);
	
	СтрукСерт = ПараметрыСертификатаСтруктура;	
	dP 			= ЧислоИзШестнадцатеричнойСтроки("0x"+СтрукСерт.DP);
	p 			= ЧислоИзШестнадцатеричнойСтроки("0x"+СтрукСерт.P);
	dQ	 		= ЧислоИзШестнадцатеричнойСтроки("0x"+СтрукСерт.DQ);
	q 			= ЧислоИзШестнадцатеричнойСтроки("0x"+СтрукСерт.Q);
	qInv 		= ЧислоИзШестнадцатеричнойСтроки("0x"+СтрукСерт.InverseQ);
	Exponent 	= ЧислоИзШестнадцатеричнойСтроки("0x"+СтрукСерт.Exponent); //открытый параметр ключа
	Modulus 	= ЧислоИзШестнадцатеричнойСтроки("0x"+СтрукСерт.Modulus); //открытый параметр ключа
	
	//s1 = pow(хешчисло,DP_Число)% P_Число;//переполнение десятичной арифметики
	
	// ↓ вычисление подписи по ускоренному алгоритму
	s1 = ВозведениеВСтепеньПоМодулю (хешчисло, dP, p);
	s2 = ВозведениеВСтепеньПоМодулю (хешчисло, dQ, q);
	Если s1>s2 Тогда
		h = ((s1-s2)*qInv)%p
	Иначе
		h = ((s1-s2+p)*qInv)%p
	КонецЕсли;
	s = s2 + q*h; //подпись - число
	// ↑
	
	ПроверкаПодписиЧисло = ВозведениеВСтепеньПоМодулю (s, Exponent, Modulus);
	подписьВерна = (ПроверкаПодписиЧисло = хешчисло);
	Если Не подписьВерна Тогда
		Сообщить("Подпись НЕ верна"); 
	КонецЕсли;
	
	Возврат ДвоичныеИзЧисла(s)
	
КонецФункции

Функция ПолучитьТокен() Экспорт
	
	СтруктураВозврата = Новый Структура("Успешно,ТекстОшибки,Токен", Ложь, "Неопределенная ошибка");
	
	СтруктураСертификата = ПолучитьСтруктуруСертификата();
	
	//Создаем base64url header+clameset for jwt
	//https://developers.google.com/identity/protocols/OAuth2ServiceAccount 
	//на странице ↑ найти и кликнуть HTTP/REST, чтоб увидеть алгоритм формирования подписи без использования гуглбиблиотек

	//хедер всегда одинаковый, можно сразу base64урл,
	//eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCJ9
	//здесь проделано для сверки с примером
	//The Base64url representation of this is as follows:
	
	СтруктураДляЖсон = Новый Структура;
	СтруктураДляЖсон.Вставить("alg", "RS256");
	СтруктураДляЖсон.Вставить("typ", "JWT");
	жсон = Новый ЗаписьJson;
	жсон.УстановитьСтроку(Новый ПараметрыЗаписиJSON(ПереносСтрокJSON.Нет));
	ЗаписатьJSON(жсон, СтруктураДляЖсон);
	СтрокаЖсонХедер = жсон.Закрыть();
	
	Хедер64 = Base64Url(ПолучитьДвоичныеДанныеИзСтроки(СтрокаЖсонХедер));
	
	СтруктураДляЖсон.Очистить();
	
	//iss 	The email address of the service account.
	СтруктураДляЖсон.Вставить("iss", СтруктураСертификата.client_email);
	
	//scope 	A space-delimited list of the permissions that the application requests.
	//смотреть какой скоп нужен например: https://developers.google.com/sheets/api/guides/authorizing
	СтруктураДляЖсон.Вставить("scope", "https://www.googleapis.com/auth/drive");
	
	//aud 	A descriptor of the intended target of the assertion. 
	//When making an access token request this value is always https://www.googleapis.com/oauth2/v4/token.
	СтруктураДляЖсон.Вставить("aud", "https://www.googleapis.com/oauth2/v4/token");
	
	//exp 	The expiration time of the assertion, specified as seconds since 00:00:00 UTC, January 1, 1970. 
	//This value has a maximum of 1 hour after the issued time.
	ВремяИстеченияUTC = УниверсальноеВремя(ТекущаяДата())+60*60;
	СекундДо = ВремяИстеченияUTC - Дата(1970,1,1);
	СтруктураДляЖсон.Вставить("exp", СекундДо);
	
	//iat 	The time the assertion was issued, specified as seconds since 00:00:00 UTC, January 1, 1970.
	СтруктураДляЖсон.Вставить("iat", СекундДо-60*60);
	
	жсон = Новый ЗаписьJson;
	жсон.УстановитьСтроку(Новый ПараметрыЗаписиJSON(ПереносСтрокJSON.Нет));
	ЗаписатьJSON(жсон, СтруктураДляЖсон);
	СтрокаЖсонКлэймСет = жсон.Закрыть();
	
	КлэймСет64 = Base64Url(ПолучитьДвоичныеДанныеИзСтроки(СтрокаЖсонКлэймСет));
	JWTдляСигнатуры = Хедер64+"."+КлэймСет64;
	
	Хеширование = Новый ХешированиеДанных(ХешФункция.SHA256);
	Хеширование.Добавить(JWTдляСигнатуры);
	ХешДвоичный = Хеширование.ХешСумма;
	
	//ОбработкаОбъект = РеквизитФормыВЗначение("Объект");
	//МакетПодписи = ОбработкаОбъект.ПолучитьМакет("Макет");
	//ХМЛТекст = ПолучитьСтрокуИзДвоичныхДанных(МакетПодписи);
	//КриптоПровайдер = Новый COMОбъект("System.Security.Cryptography.RSACryptoServiceProvider");
	//КриптоПровайдер.FromXmlString(ХМЛТекст);
	//
	//SafeArrayBinХешДляПодписи = SafeИзДвоичных(ХешДвоичный);
	//SafeArrayBinПодписьДвоичная = КриптоПровайдер.SignHash(SafeArrayBinХешДляПодписи, "SHA256");
	//ПодписьДвоичная = ДвоичныеИзSafe(SafeArrayBinПодписьДвоичная);
	
	ПодписьДвоичная = ПолучитьПодписьSHA256RSA(ХешДвоичный, СтруктураСертификата);
	Подпись64 = Base64Url(ПодписьДвоичная);
	
	JWT = JWTдляСигнатуры + "."+Подпись64;
	
	OpenSSL = Новый ЗащищенноеСоединениеOpenSSL();
	HTTPСоединение = Новый HTTPСоединение("www.googleapis.com",,,,,,OpenSSL);
	Заголовки = Новый Соответствие;
 	Заголовки.Вставить("Content-Type", "application/x-www-form-urlencoded");
	grant_type = КодироватьСтроку("urn:ietf:params:oauth:grant-type:jwt-bearer",СпособКодированияСтроки.КодировкаURL);
	HTTPЗапрос = Новый HTTPЗапрос("/oauth2/v4/token", Заголовки);
	HTTPЗапрос.УстановитьТелоИзСтроки("grant_type="+grant_type+"&assertion="+JWT);
	HTTPОтвет = HTTPСоединение.ОтправитьДляОбработки(HTTPЗапрос);
	
	ТелоОтвета = HTTPОтвет.ПолучитьТелоКакСтроку();
	
	Если HTTPОтвет.КодСостояния = 200 Тогда
		
		ЖсонПрочитан = Истина;
		
		жсон = Новый ЧтениеJSON;
		жсон.УстановитьСтроку(ТелоОтвета);
		Попытка
			СтруктураЖсон = ПрочитатьJSON(жсон);
		Исключение
			ЖсонПрочитан = Ложь;
		КонецПопытки;
		
		Если ЖсонПрочитан Тогда
			
			Токен = "";
			Если СтруктураЖсон.Свойство("access_token", Токен) Тогда
				СтруктураВозврата.Успешно = Истина;
				СтруктураВозврата.ТекстОшибки = "";
				СтруктураВозврата.Токен = Токен;
			Иначе
				СтруктураВозврата.ТекстОшибки = "Токен не определен, отсутствует свойство access_token: " + ТелоОтвета;
			КонецЕсли;
			
		Иначе
			СтруктураВозврата.ТекстОшибки = "Google вернул не json: " + ТелоОтвета;
		КонецЕсли;
	Иначе
		СтруктураВозврата.ТекстОшибки = "Токен не получен, сервер вернул: " + ТелоОтвета;
	КонецЕсли;
	
	//Если СтруктураЖсон.Свойство("access_token", токен) Тогда
	//	истекает = ТекущаяДата() + СтруктураЖсон.expires_in - 10;
	//Иначе
	//	истекает = Неопределено;
	//КонецЕсли;
	
	//адрес проверки срока токена
	//https://www.googleapis.com/oauth2/v1/tokeninfo?access_token=ya29.c.ElqEBWsnrQ_EWdMgsoHeEUTyf7s8mrXi6yx2QIeegNShgE4wm-o8i0njsj7mI3GZS1yUphtwIkS7PSUmI9sm2OkNfGYbEcjTdY1biQByhFq2hsRemXtDqlBFlig
	//HTTPЗапрос = Новый HTTPЗапрос("/oauth2/v1/tokeninfo?access_token="+токен, Заголовки);
	//HTTPОтвет = HTTPСоединение.Получить(HTTPЗапрос);
	//жсон = Новый ЧтениеJSON;
	//жсон.УстановитьСтроку(HTTPОтвет.ПолучитьТелоКакСтроку());
	//истекает = Дата(1,1,1);
	//Пока истекает = Дата(1,1,1) Цикл
	//	жсон.Прочитать();
	//	Если жсон.ТипТекущегоЗначения = ТипЗначенияJSON.ИмяСвойства и жсон.ТекущееЗначение = "expires_in" Тогда
	//		жсон.Прочитать();
	//		истекает = ТекущаяДата() + жсон.ТекущееЗначение - 10;//запас 10 секунд
	//		Прервать;
	//	КонецЕсли;
	//КонецЦикла;
	
	Возврат СтруктураВозврата;
	
КонецФункции

Функция ПолучитьСписокФайлов(Токен) Экспорт
	
	СтруктураВозврата = Новый Структура("Успешно,ТекстОшибки,Файлы", Ложь, "Неопределенная ошибка");
	
	Заголовки  = Новый Соответствие;
	Заголовки.Вставить("Authorization", "Bearer " + Токен);
	
	HTTPЗапрос = Новый HTTPЗапрос("/drive/v3/files", Заголовки);
	
	OpenSSL = Новый ЗащищенноеСоединениеOpenSSL(Неопределено, Неопределено);
	HTTPСоединение = Новый HTTPСоединение("www.googleapis.com",,,,,,OpenSSL);
	
	//Результат = Соединение.ОтправитьДляОбработки(HTTPЗапрос);// post запрос
	HTTPОтвет = HTTPСоединение.Получить(HTTPЗапрос);// get запрос
	
	ТелоОтвета = HTTPОтвет.ПолучитьТелоКакСтроку();
	
	Если HTTPОтвет.КодСостояния = 200 тогда
		ЖсонПрочитан = Истина;
		
		жсон = Новый ЧтениеJSON;
		жсон.УстановитьСтроку(ТелоОтвета);
		Попытка
			СтруктураЖсон = ПрочитатьJSON(жсон);
		Исключение
			ЖсонПрочитан = Ложь;
		КонецПопытки;
		
		Если ЖсонПрочитан Тогда
			
			Файлы = Неопределено;
			Если СтруктураЖсон.Свойство("files", Файлы) Тогда
				СтруктураВозврата.Успешно = Истина;
				СтруктураВозврата.ТекстОшибки = "";
				СтруктураВозврата.Файлы = Файлы;
			Иначе
				СтруктураВозврата.ТекстОшибки = "Файлы не определены, отсутствует свойство files: " + ТелоОтвета;
			КонецЕсли;
			
		Иначе
			СтруктураВозврата.ТекстОшибки = "Google вернул не json: " + ТелоОтвета;
		КонецЕсли;
		
	Иначе
		СтруктураВозврата.ТекстОшибки = ТелоОтвета;
	КонецЕсли;
	
	Возврат СтруктураВозврата;
	
КонецФункции

Функция СкачатьФайл(ИдФайла, Токен) Экспорт
	
	СтруктураВозврата = Новый Структура("Успешно,ТекстОшибки,Файл", Ложь, "Неопределенная ошибка");
	
	Заголовки  = Новый Соответствие;
	Заголовки.Вставить("Authorization", "Bearer " + Токен);
	
	HTTPЗапрос = Новый HTTPЗапрос("/drive/v3/files/" + ИдФайла + "?alt=media", Заголовки);
	
	OpenSSL = Новый ЗащищенноеСоединениеOpenSSL(Неопределено, Неопределено);
	HTTPСоединение = Новый HTTPСоединение("www.googleapis.com",,,,,,OpenSSL);
	
	HTTPОтвет = HTTPСоединение.Получить(HTTPЗапрос);// get запрос
	
	Если HTTPОтвет.КодСостояния = 200 тогда
		ФайлПрочитан = Истина;
		Попытка
			Файл = HTTPОтвет.ПолучитьТелоКакДвоичныеДанные();
		Исключение
			ФайлПрочитан = Ложь;
		КонецПопытки;
		Если ФайлПрочитан Тогда
			СтруктураВозврата.Успешно = Истина;
			СтруктураВозврата.ТекстОшибки = "";
			СтруктураВозврата.Файл = Файл;
		Иначе
			ТелоОтвета = HTTPОтвет.ПолучитьТелоКакСтроку();
			СтруктураВозврата.ТекстОшибки = ТелоОтвета;
		КонецЕсли;
	Иначе
		ТелоОтвета = HTTPОтвет.ПолучитьТелоКакСтроку();
		СтруктураВозврата.ТекстОшибки = ТелоОтвета;
	КонецЕсли;
	
	Возврат СтруктураВозврата;
	
КонецФункции

Функция УдалитьФайл(ИдФайла, Токен) Экспорт
	
	СтруктураВозврата = Новый Структура("Успешно,ТекстОшибки", Ложь, "Неопределенная ошибка");
	
	Заголовки  = Новый Соответствие;
	Заголовки.Вставить("Authorization", "Bearer " + Токен);
	
	//HTTPЗапрос = Новый HTTPЗапрос("/drive/v3/files/" + ИдФайла + "?supportsAllDrives=true", Заголовки);
	HTTPЗапрос = Новый HTTPЗапрос("/drive/v3/files/" + ИдФайла, Заголовки);
	
	OpenSSL = Новый ЗащищенноеСоединениеOpenSSL(Неопределено, Неопределено);
	HTTPСоединение = Новый HTTPСоединение("www.googleapis.com",,,,,,OpenSSL);
	
	HTTPОтвет = HTTPСоединение.Удалить(HTTPЗапрос);// delete запрос
	
	Если HTTPОтвет.КодСостояния = 204 тогда
		СтруктураВозврата.Успешно = Истина;
		СтруктураВозврата.ТекстОшибки = "";
	Иначе
		ТелоОтвета = HTTPОтвет.ПолучитьТелоКакСтроку();
		СтруктураВозврата.ТекстОшибки = ТелоОтвета;
	КонецЕсли;
	
	Возврат СтруктураВозврата;
	
КонецФункции


